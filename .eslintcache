[{"C:\\Users\\Thomas\\grain\\src\\index.js":"1","C:\\Users\\Thomas\\grain\\src\\App.js":"2","C:\\Users\\Thomas\\grain\\src\\reportWebVitals.js":"3","C:\\Users\\Thomas\\grain\\src\\Frame.js":"4","C:\\Users\\Thomas\\grain\\src\\registerServiceWorker.js":"5","C:\\Users\\Thomas\\grain\\src\\Indicator.js":"6","C:\\Users\\Thomas\\grain\\src\\Graph.js":"7","C:\\Users\\Thomas\\grain\\src\\Bildet.js":"8","C:\\Users\\Thomas\\grain\\src\\canvas-bezier-multipoint.js":"9","C:\\Users\\Thomas\\grain\\src\\curve.js":"10","C:\\Users\\Thomas\\grain\\src\\LPF.js":"11","C:\\Users\\Thomas\\grain\\src\\Measurer.js":"12","C:\\Users\\Thomas\\grain\\src\\useDrag.js":"13","C:\\Users\\Thomas\\grain\\src\\useDrag2.js":"14","C:\\Users\\Thomas\\grain\\src\\fili.js":"15","C:\\Users\\Thomas\\grain\\src\\Animator.js":"16","C:\\Users\\Thomas\\grain\\src\\useWindowSize.js":"17"},{"size":254,"mtime":1499981087783,"results":"18","hashOfConfig":"19"},{"size":396,"mtime":1616517577907,"results":"20","hashOfConfig":"19"},{"size":362,"mtime":499162500000,"results":"21","hashOfConfig":"22"},{"size":10789,"mtime":1623153684279,"results":"23","hashOfConfig":"19"},{"size":4022,"mtime":1499981087000,"results":"24","hashOfConfig":"19"},{"size":3631,"mtime":1622415036092,"results":"25","hashOfConfig":"19"},{"size":648,"mtime":1623152632249,"results":"26","hashOfConfig":"19"},{"size":2394,"mtime":1623152667846,"results":"27","hashOfConfig":"19"},{"size":3605,"mtime":1614717092214,"results":"28","hashOfConfig":"22"},{"size":3440,"mtime":1614719265093,"results":"29","hashOfConfig":"19"},{"size":2176,"mtime":1614722929993,"results":"30","hashOfConfig":"19"},{"size":248,"mtime":1614883848575,"results":"31","hashOfConfig":"22"},{"size":1439,"mtime":1614949481477,"results":"32","hashOfConfig":"22"},{"size":1419,"mtime":1614948903133,"results":"33","hashOfConfig":"22"},{"size":52704,"mtime":1616504287885,"results":"34","hashOfConfig":"22"},{"size":801,"mtime":1623152602369,"results":"35","hashOfConfig":"19"},{"size":1149,"mtime":1617203772482,"results":"36","hashOfConfig":"19"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},"auncpc",{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},"dxlfja",{"filePath":"45","messages":"46","errorCount":0,"warningCount":21,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"51","usedDeprecatedRules":"39"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"54","usedDeprecatedRules":"39"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":"59","usedDeprecatedRules":"60"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"63","usedDeprecatedRules":"39"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"68","usedDeprecatedRules":"69"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"69"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"69"},{"filePath":"74","messages":"75","errorCount":4,"warningCount":20,"fixableErrorCount":0,"fixableWarningCount":10,"source":"76","usedDeprecatedRules":"77"},{"filePath":"78","messages":"79","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"80","messages":"81","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},"C:\\Users\\Thomas\\grain\\src\\index.js",[],["82","83"],"C:\\Users\\Thomas\\grain\\src\\App.js",[],"C:\\Users\\Thomas\\grain\\src\\reportWebVitals.js",[],["84","85"],"C:\\Users\\Thomas\\grain\\src\\Frame.js",["86","87","88","89","90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105","106"],"C:\\Users\\Thomas\\grain\\src\\registerServiceWorker.js",[],"C:\\Users\\Thomas\\grain\\src\\Indicator.js",["107","108","109"],"// indicator component:\r\n//\t a line draggable by its endpoints,\r\n//   indicating what pixels from underlying image to process.\r\n//   for use in frame component\r\n\r\nimport React, { useState, useEffect } from 'react';\r\nimport Draggable from 'react-draggable';  // import react-draggable, which is installed via npm, for dragging elements\r\nimport './Indicator.css';\r\n \r\nfunction Indicator (props) {\r\n\r\n  const [endpointStrokeWidth, setEndpointStrokeWidth] = useState('0.42em');\r\n\r\n  // dynamic styles\r\n  const indicatorDivStyle = {\r\n    position: 'relative',\r\n    //backgroundColor: 'red',\r\n\r\n    width: '100%',\r\n    height: '100%',\r\n    //top: '50%',\r\n    //left: '50%',\r\n    //transform: 'translate(-50%, -50%)',\r\n  };\r\n\r\n  const lineStyle = {\r\n    position: 'absolute',\r\n    stroke: '#6b6b6b',\r\n    strokeWidth: '0.2em',\r\n    opacity: '0.7',\r\n  };\r\n\r\n  const circleDivStyle = {\r\n    display: 'inline-block',\r\n    height: '30px',\r\n    width: '30px',\r\n    zIndex: 2\r\n  };\r\n\r\n  const circleStyleDark = {\r\n    stroke: '#554444',\r\n    opacity: '0.3',\r\n    fill: 'none',\r\n    strokeWidth: endpointStrokeWidth\r\n  };\r\n\r\n  const circleStyle = {\r\n    stroke: '#554444',\r\n    opacity: '0.3',\r\n    fill: 'none',\r\n    strokeWidth: endpointStrokeWidth\r\n  };\r\n\r\n  const svgteststyle = {\r\n    transform: 'translate(-2.5em, -2.5em)',\r\n    top: '30px',\r\n    //backgroundColor: 'red',\r\n    preserveAspectRatio: \"none\",\r\n  }\r\n\r\n  const svgLineStyle = {\r\n    position: 'absolute'\r\n  }\r\n\r\n  // on every change in state\r\n  useEffect(() => {\r\n      console.log('useeffect indicator with x, y ' + props.x1 + ', ' + props.y1);\r\n\r\n  });\r\n\r\n  function handleMove5 (e, ui) {\r\n    props.xyChange(0, ui.x, ui.y);\r\n    // console.log('handle1 ui x ' + ui.x + ' ui y ' + ui.y);\r\n  }\r\n\r\n  function handleMove6 (e, ui) {\r\n    props.xyChange(1, ui.x, ui.y);\r\n    // console.log('handle2 ui x ' + ui.x + ' ui y ' + ui.y);\r\n  }\r\n\r\n  return (\r\n    \r\n    // indicator container div\r\n    // line is 0 + because otherwise it assumes some default strange pos\r\n    // +0 because style transform needs an int in  order to work\r\n    <div id=\"indicator\" style={indicatorDivStyle}>\r\n      \r\n      {/*line*/}\r\n      <svg style={svgLineStyle} width=\"100%\" height=\"100%\" >\r\n        <line id='line'\r\n              style={lineStyle}\r\n              x1={props.x1 + 0}\r\n              y1={props.y1 + 0}\r\n              x2={props.x2 + 0}\r\n              y2={props.y2 + 0} />\r\n      </svg>\r\n\r\n      {/*handle l*/}\r\n      <Draggable\r\n        id='draggable1'\r\n        axis=\"both\"\r\n        handle=\".handle\"\r\n        position={{x: props.x1, y: props.y1}}\r\n        scale={1}\r\n        onDrag={handleMove5}\r\n        // onStop={handleStop5p}\r\n        >  \r\n        \r\n        <div id='handle1'>\r\n    \r\n          <svg style={svgteststyle}    \r\n            className=\"handle\"\r\n            width='5em'\r\n            height=\"5em\"\r\n            viewBox=\"56 56 112 112\">\r\n\r\n            <circle style={circleStyle} cx={'112'} cy={'112'} r={'25'}/>\r\n          </svg>\r\n        </div>\r\n      </Draggable>\r\n\r\n      {/*handle r*/}\r\n      <Draggable\r\n        id='draggable2'\r\n        axis=\"both\"\r\n        handle=\".handle\"\r\n        position={{x: props.x2, y: props.y2}}\r\n        scale={1}\r\n        onDrag={handleMove6}\r\n        >  \r\n        \r\n        <div id='handle2'>\r\n      \r\n          <svg style={svgteststyle}    \r\n            className=\"handle\"\r\n            width='5em'\r\n            height=\"5em\"\r\n            viewBox=\"0 0 112 112\">\r\n\r\n            <circle style={circleStyle} cx={'56'} cy={'56'} r={'25'}/>\r\n          </svg>\r\n        </div>\r\n      </Draggable>\r\n\r\n\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Indicator;","C:\\Users\\Thomas\\grain\\src\\Graph.js",["110"],"//image from which to extract data, based on position of indicator line overlay\r\n//cutout       <p id='graphTitle'>graph represents image brightness along line between circles</p>\r\n\r\n\r\nimport React, { useEffect } from 'react';\r\nimport './Graph.css';\r\n\r\nfunction Graph (props) {\r\n  return (\r\n    <div className='graph'> {/*comment here*/}\r\n      <canvas ref={props.passRef} id=\"drawingCanvas\" width={props.drawingCanvasWidth} height={props.drawingCanvasHeight}></canvas>\r\n      <svg id='playIndexLine' width=\"10%\" height=\"100%\" >\r\n        <line id='line' x1='22' y1='0' x2='22' y2='200' />\r\n      </svg>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Graph;","C:\\Users\\Thomas\\grain\\src\\Bildet.js",[],"C:\\Users\\Thomas\\grain\\src\\canvas-bezier-multipoint.js",["111","112"],"export function bezierCurveThrough(ctx, points, tension) {\n    'use strict';\n\n    // Default tension of one-quarter gives nice results\n    tension = tension || 0.25;\n\n    var l = points.length;\n\n    // If we're given less than two points, there's nothing we can do\n    if (l < 2) return;\n\n    ctx.beginPath();\n\n    // If we only have two points, we can only draw a straight line\n    if (l == 2) {\n        ctx.moveTo(points[0][0], points[0][1]);\n        ctx.lineTo(points[1][0], points[1][1]);\n        ctx.stroke();\n        return;\n    }\n\n    // Helper function to calculate the hypotenuse\n    function h(x, y) {\n        return Math.sqrt(x * x + y * y);\n    }\n\n    /* For each interior point, we need to calculate the tangent and pick\n     * two points on it that'll serve as control points for curves to and\n     * from the point. */\n    var cpoints = [];\n    points.forEach(function() {\n        cpoints.push({});\n    });\n\n    for (var i = 1; i < l - 1; i++) {\n        var pi = points[i],     // current point\n            pp = points[i - 1], // previous point\n            pn = points[i + 1]; // next point;\n\n        /* First, we calculate the normalized tangent slope vector (dx,dy).\n         * We intentionally don't work with the derivative so we don't have\n         * to handle the vertical line edge cases separately. */\n\n        var rdx = pn[0] - pp[0],  // actual delta-x between previous and next points\n            rdy = pn[1] - pp[1],  // actual delta-y between previous and next points\n            rd = h(rdx, rdy),     // actual distance between previous and next points\n            dx = rdx / rd,        // normalized delta-x (so the total distance is 1)\n            dy = rdy / rd;        // normalized delta-y (so the total distance is 1)\n\n        /* Next we calculate distances to previous and next points, so we\n         * know how far out to put the control points on the tangents (tension).\n         */\n\n        var dp = h(pi[0] - pp[0], pi[1] - pp[1]), // distance to previous point\n            dn = h(pi[0] - pn[0], pi[1] - pn[1]); // distance to next point\n\n        /* Now we can calculate control points. Previous control point is\n         * located on the tangent of the curve, with the distance between it\n         * and the current point being a fraction of the distance between the\n         * current point and the previous point. Analogous to next point. */\n\n        var cpx = pi[0] - dx * dp * tension,\n            cpy = pi[1] - dy * dp * tension,\n            cnx = pi[0] + dx * dn * tension,\n            cny = pi[1] + dy * dn * tension;\n\n        cpoints[i] = {\n            cp: [cpx, cpy], // previous control point\n            cn: [cnx, cny], // next control point\n       };\n    }\n\n    /* For the end points, we only need to calculate one control point.\n     * Picking a point in the middle between the endpoint and the other's\n     * control point seems to work well. */\n\n    cpoints[0] = {\n        cn: [ (points[0][0] + cpoints[1].cp[0]) / 2, (points[0][1] + cpoints[1].cp[1]) / 2 ],\n    };\n    cpoints[l - 1] = {\n        cp: [ (points[l - 1][0] + cpoints[l - 2].cn[0]) / 2, (points[l - 1][1] + cpoints[l - 2].cn[1]) / 2 ],\n    };\n\n    /* Now we can draw! */\n\n    ctx.moveTo(points[0][0], points[0][1]);\n\n    for (i = 1; i < l; i++) {\n        var p = points[i],\n            cp = cpoints[i],\n            cpp = cpoints[i - 1];\n\n        /* Each bezier curve uses the \"next control point\" of first point\n         * point, and \"previous control point\" of second point. */\n        ctx.bezierCurveTo(cpp.cn[0], cpp.cn[1], cp.cp[0], cp.cp[1], p[0], p[1]);\n    }\n\n    ctx.stroke();\n}\n",["113","114"],"C:\\Users\\Thomas\\grain\\src\\curve.js",["115"],"/*!\tCurve extension for canvas 2.3.1\r\n *\tEpistemex (c) 2013-2014\r\n *\tLicense: MIT\r\n */\r\n\r\n/**\r\n * Draws a cardinal spline through given point array. Points must be arranged\r\n * as: [x1, y1, x2, y2, ..., xn, yn]. It adds the points to the current path.\r\n *\r\n * The method continues previous path of the context. If you don't want that\r\n * then you need to use moveTo() with the first point from the input array.\r\n *\r\n * The points for the cardinal spline are returned as a new array.\r\n *\r\n * @param {Array} points - point array\r\n * @param {Number} [tension=0.5] - tension. Typically between [0.0, 1.0] but can be exceeded\r\n * @param {Number} [numOfSeg=20] - number of segments between two points (line resolution)\r\n * @param {Boolean} [close=false] - Close the ends making the line continuous\r\n * @returns {Float32Array} New array with the calculated points that was added to the path\r\n */\r\nCanvasRenderingContext2D.prototype.curve = CanvasRenderingContext2D.prototype.curve || function(points, tension, numOfSeg, close) {\r\n\r\n\t'use strict';\r\n\r\n\t// options or defaults\r\n\ttension = (typeof tension === 'number') ? tension : 0.5;\r\n\tnumOfSeg = numOfSeg ? numOfSeg : 25;\r\n\r\n\tvar pts,\t\t\t\t\t\t\t\t\t// for cloning point array\r\n\t\ti = 1,\r\n\t\tl = points.length,\r\n\t\trPos = 0,\r\n\t\trLen = (l-2) * numOfSeg + 2 + (close ? 2 * numOfSeg: 0),\r\n\t\tres = new Float32Array(rLen),\r\n\t\tcache = new Float32Array((numOfSeg + 2) * 4),\r\n\t\tcachePtr = 4;\r\n\r\n\tpts = points.slice(0);\r\n\r\n\tif (close) {\r\n\t\tpts.unshift(points[l - 1]);\t\t\t\t// insert end point as first point\r\n\t\tpts.unshift(points[l - 2]);\r\n\t\tpts.push(points[0], points[1]); \t\t// first point as last point\r\n\t}\r\n\telse {\r\n\t\tpts.unshift(points[1]);\t\t\t\t\t// copy 1. point and insert at beginning\r\n\t\tpts.unshift(points[0]);\r\n\t\tpts.push(points[l - 2], points[l - 1]);\t// duplicate end-points\r\n\t}\r\n\r\n\t// cache inner-loop calculations as they are based on t alone\r\n\tcache[0] = 1;\t\t\t\t\t\t\t\t// 1,0,0,0\r\n\r\n\tfor (; i < numOfSeg; i++) {\r\n\r\n\t\tvar st = i / numOfSeg,\r\n\t\t\tst2 = st * st,\r\n\t\t\tst3 = st2 * st,\r\n\t\t\tst23 = st3 * 2,\r\n\t\t\tst32 = st2 * 3;\r\n\r\n\t\tcache[cachePtr++] =\tst23 - st32 + 1;\t// c1\r\n\t\tcache[cachePtr++] =\tst32 - st23;\t\t// c2\r\n\t\tcache[cachePtr++] =\tst3 - 2 * st2 + st;\t// c3\r\n\t\tcache[cachePtr++] =\tst3 - st2;\t\t\t// c4\r\n\t}\r\n\r\n\tcache[++cachePtr] = 1;\t\t\t\t\t\t// 0,1,0,0\r\n\r\n\t// calc. points\r\n\tparse(pts, cache, l);\r\n\r\n\tif (close) {\r\n\t\t//l = points.length;\r\n\t\tpts = [];\r\n\t\tpts.push(points[l - 4], points[l - 3], points[l - 2], points[l - 1]); // second last and last\r\n\t\tpts.push(points[0], points[1], points[2], points[3]); // first and second\r\n\t\tparse(pts, cache, 4);\r\n\t}\r\n\r\n\tfunction parse(pts, cache, l) {\r\n\r\n\t\tfor (var i = 2, t; i < l; i += 2) {\r\n\r\n\t\t\tvar pt1 = pts[i],\r\n\t\t\t\tpt2 = pts[i+1],\r\n\t\t\t\tpt3 = pts[i+2],\r\n\t\t\t\tpt4 = pts[i+3],\r\n\r\n\t\t\t\tt1x = (pt3 - pts[i-2]) * tension,\r\n\t\t\t\tt1y = (pt4 - pts[i-1]) * tension,\r\n\t\t\t\tt2x = (pts[i+4] - pt1) * tension,\r\n\t\t\t\tt2y = (pts[i+5] - pt2) * tension;\r\n\r\n\t\t\tfor (t = 0; t < numOfSeg; t++) {\r\n\r\n\t\t\t\tvar c = t << 2, //t * 4;\r\n\r\n\t\t\t\t\tc1 = cache[c],\r\n\t\t\t\t\tc2 = cache[c+1],\r\n\t\t\t\t\tc3 = cache[c+2],\r\n\t\t\t\t\tc4 = cache[c+3];\r\n\r\n\t\t\t\tres[rPos++] = c1 * pt1 + c2 * pt3 + c3 * t1x + c4 * t2x;\r\n\t\t\t\tres[rPos++] = c1 * pt2 + c2 * pt4 + c3 * t1y + c4 * t2y;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// add last point\r\n\tl = close ? 0 : points.length - 2;\r\n\tres[rPos++] = points[l];\r\n\tres[rPos] = points[l+1];\r\n\r\n\t// add lines to path\r\n\tfor(i = 0, l = res.length; i < l; i += 2)\r\n\t\tthis.lineTo(res[i], res[i+1]);\r\n\r\n\treturn res;\r\n};","C:\\Users\\Thomas\\grain\\src\\LPF.js",[],"C:\\Users\\Thomas\\grain\\src\\Measurer.js",["116"],"\r\nimport './Measurer.css';\r\nimport React, { useEffect } from 'react';\r\n\r\nfunction Measurer (props) {\r\n\r\n    return (\r\n        <div id={props.id}>\r\n          <p>bildet: {props.x1}, {props.y1}</p>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Measurer;",["117","118"],"C:\\Users\\Thomas\\grain\\src\\useDrag.js",[],"C:\\Users\\Thomas\\grain\\src\\useDrag2.js",[],"C:\\Users\\Thomas\\grain\\src\\fili.js",["119","120","121","122","123","124","125","126","127","128","129","130","131","132","133","134","135","136","137","138","139","140","141","142"],"/**\n * @name    fili\n * @version 2.0.3 | December 13th 2018\n * @author  Florian Markert\n * @license MIT\n */\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Fili = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n\n  CalcCascades: require('./src/calcCascades'),\n  Fft: require('./src/fft'),\n  FirCoeffs: require('./src/firCoeffs'),\n  FirFilter: require('./src/firFilter'),\n  IirCoeffs: require('./src/iirCoeffs'),\n  IirFilter: require('./src/iirFilter'),\n  TestFilter: require('./src/testFilter')\n\n};\n\n},{\"./src/calcCascades\":2,\"./src/fft\":3,\"./src/firCoeffs\":4,\"./src/firFilter\":5,\"./src/iirCoeffs\":6,\"./src/iirFilter\":7,\"./src/testFilter\":8}],2:[function(require,module,exports){\n'use strict';\n\nvar IirCoeffs = require('./iirCoeffs');\n\nvar getCoeffs = new IirCoeffs();\n\nvar table = {\n  // values from https://gist.github.com/endolith/4982787#file-all-values-txt\n  bessel: {\n    q: [[0.57735026919], [0.805538281842, 0.521934581669], [1.02331395383, 0.611194546878, 0.510317824749], [1.22566942541, 0.710852074442, 0.559609164796, 0.505991069397], [1.41530886916, 0.809790964842, 0.620470155556, 0.537552151325, 0.503912727276], [1.59465693507, 0.905947107025, 0.684008068137, 0.579367238641, 0.525936202016, 0.502755558204], [1.76552743493, 0.998998442993, 0.747625068271, 0.624777082395, 0.556680772868, 0.519027293158, 0.502045428643], [1.9292718407, 1.08906376917, 0.810410302962, 0.671382379377, 0.591144659703, 0.542678365981, 0.514570953471, 0.501578400482], [2.08691792612, 1.17637337045, 0.872034231424, 0.718163551101, 0.627261751983, 0.569890924765, 0.533371782078, 0.511523796759, 0.50125489338], [2.23926560629, 1.26117120993, 0.932397288146, 0.764647810579, 0.664052481472, 0.598921924986, 0.555480327396, 0.526848630061, 0.509345928377, 0.501021580965], [2.38695091667, 1.34368488961, 0.991497755204, 0.81060830488, 0.701011199665, 0.628878390935, 0.57943181849, 0.545207253735, 0.52208637596, 0.507736060535, 0.500847111042], [2.53048919562, 1.42411783481, 1.04937620183, 0.85593899901, 0.737862159044, 0.659265671705, 0.604435823473, 0.565352679646, 0.537608804383, 0.51849505465, 0.506508536474, 0.500715908905]],\n    f3dB: [[1.27201964951], [1.60335751622, 1.43017155999], [1.9047076123, 1.68916826762, 1.60391912877], [2.18872623053, 1.95319575902, 1.8320926012, 1.77846591177], [2.45062684305, 2.20375262593, 2.06220731793, 1.98055310881, 1.94270419166], [2.69298925084, 2.43912611431, 2.28431825401, 2.18496722634, 2.12472538477, 2.09613322542], [2.91905714471, 2.66069088948, 2.49663434571, 2.38497976939, 2.30961462222, 2.26265746534, 2.24005716132], [3.13149167404, 2.87016099416, 2.69935018044, 2.57862945683, 2.49225505119, 2.43227707449, 2.39427710712, 2.37582307687], [3.33237300564, 3.06908580184, 2.89318259511, 2.76551588399, 2.67073340527, 2.60094950474, 2.55161764546, 2.52001358804, 2.50457164552], [3.52333123464, 3.25877569704, 3.07894353744, 2.94580435024, 2.84438325189, 2.76691082498, 2.70881411245, 2.66724655259, 2.64040228249, 2.62723439989], [3.70566068548, 3.44032173223, 3.2574059854, 3.11986367838, 3.01307175388, 2.92939234605, 2.86428726094, 2.81483068055, 2.77915465405, 2.75596888377, 2.74456638588], [3.88040469682, 3.61463243697, 3.4292654707, 3.28812274966, 3.17689762788, 3.08812364257, 3.01720732972, 2.96140104561, 2.91862858495, 2.88729479473, 2.8674198668, 2.8570800015]],\n    f1dB: [[2.16477559371], [2.70320928596, 2.41122332505], [3.25676581436, 2.88822569572, 2.74246238837], [3.76153580353, 3.35675411406, 3.14862673032, 3.05646412475], [4.22174260104, 3.79644757806, 3.55260471864, 3.41193742197, 3.34673435508], [4.64584812552, 4.20789257981, 3.94082363122, 3.76942681446, 3.66549975744, 3.61617359345], [5.04060395196, 4.5944592201, 4.3111677248, 4.11836351827, 3.98822359814, 3.90713836715, 3.86811234525], [5.41107948467, 4.95951159709, 4.66435804468, 4.45575796102, 4.30650679478, 4.20286750045, 4.13720522991, 4.10531748119], [5.76110791853, 5.30592898465, 5.00182215701, 4.7811081045, 4.61724509926, 4.49660100894, 4.41131378918, 4.35667671372, 4.32997951075], [6.09364309488, 5.63609116014, 5.32506930789, 5.09480346139, 4.91939504255, 4.78540258409, 4.68493280536, 4.61302286993, 4.56661931366, 4.54382759952], [6.41100731543, 5.95195558182, 5.63550073656, 5.39754464742, 5.21278891332, 5.06801430334, 4.95539684456, 4.8697869429, 4.80814951843, 4.76793469612, 4.74828032403], [6.71506056052, 6.25514029778, 5.9343616072, 5.69011422355, 5.49763642361, 5.34401973764, 5.22125973611, 5.12485045619, 5.05037962112, 4.99699982231, 4.96155789635, 4.94441828777]]\n  }\n};\n\n// from Texas Instruments \"Op Amps for Everyone\" Chapter 16 \"Active Filter Design Techniques\"\nvar tiTable = {\n  bessel: {\n    as: [[1.3617], [1.3397, 0.7743], [1.2217, 0.9686, 0.5131], [1.1112, 0.9754, 0.7202, 0.3728], [1.0215, 0.9393, 0.7815, 0.5604, 0.2883]],\n    bs: [[0.6180], [0.4889, 0.3890], [0.3887, 0.3505, 0.2756], [0.3162, 0.2979, 0.2621, 0.2087], [0.2650, 0.2549, 0.2351, 0.2059, 0.1665]]\n  },\n  butterworth: {\n    as: [[1.4142], [1.8478, 0.7654], [1.9319, 1.4142, 0.5176], [1.9616, 1.6629, 1.1111, 0.3902], [1.9754, 1.7820, 1.4142, 0.9080, 0.3129]],\n    bs: [[1.0], [1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0, 1.0]]\n  },\n  tschebyscheff05: {\n    as: [[1.3614], [2.6282, 0.3648], [3.8645, 0.7528, 0.1589], [5.1117, 1.0639, 0.3439, 0.0885], [6.3648, 1.3582, 0.4822, 0.1994, 0.0563]],\n    bs: [[1.3827], [3.4341, 1.1509], [6.9797, 1.8573, 1.0711], [11.9607, 2.9365, 1.4206, 1.0407], [18.3695, 4.3453, 1.9440, 1.2520, 1.0263]]\n  },\n  tschebyscheff1: {\n    as: [[1.3022], [2.5904, 0.3039], [3.8437, 0.6292, 0.1296], [5.1019, 0.8916, 0.2806, 0.0717], [6.3634, 1.1399, 0.3939, 0.1616, 0.0455]],\n    bs: [[1.5515], [4.1301, 1.1697], [8.5529, 1.9124, 1.0766], [14.7608, 3.0426, 1.4334, 1.0432], [22.7468, 4.5167, 1.9665, 1.2569, 1.0277]]\n  },\n  tschebyscheff2: {\n    as: [[1.1813], [2.4025, 0.2374], [3.5880, 0.4925, 0.0995], [4.7743, 0.6991, 0.2153, 0.0547], [5.9618, 0.8947, 0.3023, 0.1233, 0.0347]],\n    bs: [[1.7775], [4.9862, 1.1896], [10.4648, 1.9622, 1.0826], [18.1510, 3.1353, 1.4449, 1.0461], [28.0376, 4.6644, 1.9858, 1.2614, 1.0294]]\n  },\n  tschebyscheff3: {\n    as: [[1.0650], [2.1853, 0.1964], [3.2721, 0.4077, 0.0815], [4.3583, 0.5791, 0.1765, 0.0448], [5.4449, 0.7414, 0.2479, 0.1008, 0.0283]],\n    bs: [[1.9305], [5.5339, 1.2009], [11.6773, 1.9873, 1.0861], [20.2948, 3.1808, 1.4507, 1.0478], [31.3788, 4.7363, 1.9952, 1.2638, 1.0304]]\n  },\n  allpass: {\n    as: [[1.6278], [2.3370, 1.3506], [2.6117, 2.0706, 1.0967], [2.7541, 2.4174, 1.7850, 0.9239], [2.8406, 2.6120, 2.1733, 1.5583, 0.8018]],\n    bs: [[0.8832], [1.4878, 1.1837], [1.7763, 1.6015, 1.2596], [1.9420, 1.8300, 1.6101, 1.2822], [2.0490, 1.9714, 1.8184, 1.5923, 1.2877]]\n  }\n};\n\nvar calcCoeffs = function calcCoeffs(params, behavior) {\n  var filter = [];\n  var cnt = 0;\n  if (behavior !== 'fromPZ') {\n    if (params.order > 12) {\n      params.order = 12;\n    }\n    for (cnt = 0; cnt < params.order; cnt++) {\n      var q, f, fd;\n      if (params.transform === 'matchedZ') {\n        filter.push(getCoeffs['lowpassMZ']({\n          Fs: params.Fs,\n          Fc: params.Fc,\n          preGain: params.preGain,\n          as: tiTable[params.characteristic].as[params.order - 1][cnt],\n          bs: tiTable[params.characteristic].bs[params.order - 1][cnt]\n        }));\n      } else {\n        if (params.characteristic === 'butterworth') {\n          q = 0.5 / Math.sin(Math.PI / (params.order * 2) * (cnt + 0.5));\n          f = 1;\n        } else {\n          q = table[params.characteristic].q[params.order - 1][cnt];\n          if (params.oneDb) {\n            f = table[params.characteristic].f1dB[params.order - 1][cnt];\n          } else {\n            f = table[params.characteristic].f3dB[params.order - 1][cnt];\n          }\n        }\n\n        if (behavior === 'highpass') {\n          fd = params.Fc / f;\n        } else {\n          fd = params.Fc * f;\n        }\n        if (behavior === 'bandpass' || behavior === 'bandstop') {\n          if (params.characteristic === 'bessel') {\n            fd = Math.sqrt(params.order) * fd / params.order;\n          }\n        }\n        filter.push(getCoeffs[behavior]({\n          Fs: params.Fs,\n          Fc: fd,\n          Q: q,\n          BW: params.BW || 0,\n          gain: params.gain || 0,\n          preGain: params.preGain || false\n        }));\n      }\n    }\n  } else {\n    for (cnt = 0; cnt < params.length; cnt++) {\n      filter.push(getCoeffs[behavior](params[cnt]));\n    }\n  }\n\n  return filter;\n};\n\nvar initCalcCoeffs = function initCalcCoeffs(behavior) {\n  return function (params) {\n    return calcCoeffs(params, behavior);\n  };\n};\n\nvar self = {};\nvar CalcCascades = function CalcCascades() {\n  var available = [];\n  for (var k in getCoeffs) {\n    self[k] = initCalcCoeffs(k);\n    available.push(k);\n  }\n  self.available = function () {\n    return available;\n  };\n  return self;\n};\n\nmodule.exports = CalcCascades;\n\n},{\"./iirCoeffs\":6}],3:[function(require,module,exports){\n'use strict';\n\nvar Fft = function Fft(radix) {\n  var isPowerOfTwo = function isPowerOfTwo(value) {\n    if (!(value & value - 1)) {\n      return true;\n    }\n    return false;\n  };\n\n  if (!isPowerOfTwo(radix)) {\n    return false;\n  }\n\n  var fft = {};\n  fft.length = radix;\n  fft.buffer = new Float64Array(radix);\n  fft.re = new Float64Array(radix);\n  fft.im = new Float64Array(radix);\n  fft.reI = new Float64Array(radix);\n  fft.imI = new Float64Array(radix);\n\n  fft.twiddle = new Int32Array(radix);\n  fft.sinTable = new Float64Array(radix - 1);\n  fft.cosTable = new Float64Array(radix - 1);\n  var TPI = 2 * Math.PI;\n  var bits = Math.floor(Math.log(radix) / Math.LN2);\n\n  for (i = fft.sinTable.length; i--;) {\n    fft.sinTable[i] = Math.sin(TPI * (i / radix));\n    fft.cosTable[i] = Math.cos(TPI * (i / radix));\n  }\n\n  var nh = radix >> 1;\n  var i = 0;\n  var j = 0;\n  for (;;) {\n    fft.twiddle[i] = j;\n    if (++i >= radix) {\n      break;\n    }\n    bits = nh;\n    while (bits <= j) {\n      j -= bits;\n      bits >>= 1;\n    }\n    j += bits;\n  }\n\n  // good explanation in https://holometer.fnal.gov/GH_FFT.pdf\n\n  var PI = Math.PI;\n  var PI2 = Math.PI * 2;\n  var abs = Math.abs;\n  var pow = Math.pow;\n  var cos = Math.cos;\n  var sin = Math.sin;\n  var sinc = function sinc(x) {\n    return sin(PI * x) / (PI * x);\n  };\n  var E = Math.E;\n\n  var windowCalculation = {\n    rectangular: {\n      calc: function calc() {\n        return 1;\n      },\n      values: [],\n      correction: 1\n    },\n    none: {\n      calc: function calc() {\n        return 1;\n      },\n      values: [],\n      correction: 1\n    },\n    hanning: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.5 * (1 - cos(z));\n      },\n      values: [],\n      correction: 2\n    },\n    hamming: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.54 - 0.46 * cos(z);\n      },\n      values: [],\n      correction: 1.8518999946875638\n    },\n    tukery: {\n      calc: function calc(n, N, a) {\n        if (n < a * (N - 1) / 2) {\n          return 0.5 * (1 + cos(PI * (2 * n / (a * (N - 1)) - 1)));\n        } else if ((N - 1) * (1 - a / 2) < n) {\n          return 0.5 * (1 + cos(PI * (2 * n / (a * (N - 1)) - 2 / a + 1)));\n        } else {\n          return 1;\n        }\n      },\n      values: [],\n      correction: 4 / 3\n    },\n    cosine: {\n      calc: function calc(n, N) {\n        return sin(PI * n / (N - 1));\n      },\n      values: [],\n      correction: 1.570844266360796\n    },\n    lanczos: {\n      calc: function calc(n, N) {\n        return sinc(2 * n / (N - 1) - 1);\n      },\n      values: [],\n      correction: 1.6964337576195783\n    },\n    triangular: {\n      calc: function calc(n, N) {\n        return 2 / (N + 1) * ((N + 1) / 2 - abs(n - (N - 1) / 2));\n      },\n      values: [],\n      correction: 2\n    },\n    bartlett: {\n      calc: function calc(n, N) {\n        return 2 / (N - 1) * ((N - 1) / 2 - abs(n - (N - 1) / 2));\n      },\n      values: [],\n      correction: 2\n    },\n    gaussian: {\n      calc: function calc(n, N, a) {\n        return pow(E, -0.5 * pow((n - (N - 1) / 2) / (a * (N - 1) / 2), 2));\n      },\n      values: [],\n      correction: 5 / 3\n    },\n    bartlettHanning: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.62 - 0.48 * abs(n / (N - 1) - 0.5) - 0.38 * cos(z);\n      },\n      values: [],\n      correction: 2\n    },\n    blackman: {\n      calc: function calc(n, N, a) {\n        var a0 = (1 - a) / 2;\n        var a1 = 0.5;\n        var a2 = a / 2;\n        var z = PI2 * n / (N - 1);\n        return a0 - a1 * cos(z) + a2 * cos(2 * z);\n      },\n      values: [],\n      correction: 4 / 3\n    },\n    blackmanHarris: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.35875 - 0.48829 * cos(z) + 0.14128 * cos(2 * z) - 0.01168 * cos(3 * z);\n      },\n      values: [],\n      correction: 1.5594508635\n    },\n    nuttall3: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.375 - 0.5 * cos(z) + 0.125 * cos(2 * z);\n      },\n      values: [],\n      correction: 1.56\n    },\n    nuttall3a: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.40897 - 0.5 * cos(z) + 0.09103 * cos(2 * z);\n      },\n      values: [],\n      correction: 1.692\n    },\n    nuttall3b: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.4243801 - 0.4973406 * cos(z) + 0.078793 * cos(2 * z);\n      },\n      values: [],\n      correction: 1.7372527\n    },\n    nuttall4: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.3125 - 0.46875 * cos(z) + 0.1875 * cos(2 * z) - 0.03125 * cos(3 * z);\n      },\n      values: [],\n      correction: 1.454543\n    },\n    nuttall4a: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.338946 - 0.481973 * cos(z) + 0.161054 * cos(2 * z) - 0.018027 * cos(3 * z);\n      },\n      values: [],\n      correction: 1.512732763\n    },\n    nuttall4b: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.355768 - 0.481973 * cos(z) + 0.144232 * cos(2 * z) - 0.012604 * cos(3 * z);\n      },\n      values: [],\n      correction: 1.55223262\n    },\n    nuttall4c: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.3635819 - 0.4891775 * cos(z) + 0.1365995 * cos(2 * z) - 0.0106411 * cos(3 * z);\n      },\n      values: [],\n      correction: 1.57129067\n    },\n    // fast decaying flat top\n    sft3f: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.26526 - 0.5 * cos(z) + 0.23474 * cos(2 * z);\n      },\n      values: [],\n      correction: 1.3610238\n    },\n    sft4f: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.21706 - 0.42103 * cos(z) + 0.28294 * cos(2 * z) - 0.07897 * cos(3 * z);\n      },\n      values: [],\n      correction: 1.2773573\n    },\n    sft5f: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.1881 - 0.36923 * cos(z) + 0.28702 * cos(2 * z) - 0.13077 * cos(3 * z) + 0.02488 * cos(4 * z);\n      },\n      values: [],\n      correction: 1.23167769\n    },\n    // minimum sidelobe flat top\n    sft3m: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.28235 - 0.52105 * cos(z) + 0.19659 * cos(2 * z);\n      },\n      values: [],\n      correction: 1.39343451\n    },\n    sft4m: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.241906 - 0.460841 * cos(z) + 0.2552381 * cos(2 * z) - 0.041872 * cos(3 * z);\n      },\n      values: [],\n      correction: 1.3190596\n    },\n    sft5m: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.209671 - 0.407331 * cos(z) + 0.281225 * cos(2 * z) - 0.092669 * cos(3 * z) + 0.0091036 * cos(4 * z);\n      },\n      values: [],\n      correction: 1.26529456464\n    },\n    nift: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.2810639 - 0.5208972 * cos(z) + 0.1980399 * cos(2 * z);\n      },\n      values: [],\n      correction: 1.39094182\n    },\n    hpft: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return (1.0 - 1.912510941 * cos(z) + 1.079173272 * cos(2 * z) - 0.1832630879 * cos(3 * z)) / N;\n      },\n      values: [],\n      correction: 1\n    },\n    srft: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return (1.0 - 1.93 * cos(z) + 1.29 * cos(2 * z) - 0.388 * cos(3 * z) + 0.028 * cos(4 * z)) / N;\n      },\n      values: [],\n      correction: 1\n    },\n    hft70: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return (1.0 - 1.90796 * cos(z) + 1.07349 * cos(2 * z) - 0.18199 * cos(3 * z)) / N;\n      },\n      values: [],\n      correction: 1\n    },\n    hft95: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return (1.0 - 1.9383379 * cos(z) + 1.3045202 * cos(2 * z) - 0.402827 * cos(3 * z) + 0.0350665 * cos(4 * z)) / N;\n      },\n      values: [],\n      correction: 1\n    },\n    hft90d: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return (1.0 - 1.942604 * cos(z) + 1.340318 * cos(2 * z) - 0.440811 * cos(3 * z) + 0.043097 * cos(4 * z)) / N;\n      },\n      values: [],\n      correction: 1\n    },\n    hft116d: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return (1.0 - 1.9575375 * cos(z) + 1.4780705 * cos(2 * z) - 0.6367431 * cos(3 * z) + 0.1228389 * cos(4 * z) - 0.0066288 * cos(5 * z)) / N;\n      },\n      values: [],\n      correction: 1\n    },\n    hft144d: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return (1.0 - 1.96760033 * cos(z) + 1.57983607 * cos(2 * z) - 0.81123644 * cos(3 * z) + 0.22583558 * cos(4 * z) - 0.02773848 * cos(5 * z) + 0.0009036 * cos(6 * z)) / N;\n      },\n      values: [],\n      correction: 1\n    },\n    hft196d: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return (1.0 - 1.97441842 * cos(z) + 1.65409888 * cos(2 * z) - 0.95788186 * cos(3 * z) + 0.3367342 * cos(4 * z) - 0.06364621 * cos(5 * z) + 0.00521942 * cos(6 * z) - 0.00010599 * cos(7 * z)) / N;\n      },\n      values: [],\n      correction: 1\n    },\n    hft223d: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return (1.0 - 1.98298997309 * cos(z) + 1.75556083063 * cos(2 * z) - 1.19037717712 * cos(3 * z) + 0.56155440797 * cos(4 * z) - 0.17296769663 * cos(5 * z) + 0.03233247087 * cos(6 * z) - 0.00324954578 * cos(7 * z) + 0.00013801040 * cos(8 * z) - 0.00000132725 * cos(9 * z)) / N;\n      },\n      values: [],\n      correction: 1\n    },\n    hft248d: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return (1.0 - 1.985844164102 * cos(z) + 1.791176438506 * cos(2 * z) - 1.282075284005 * cos(3 * z) + 0.667777530266 * cos(4 * z) - 0.240160796576 * cos(5 * z) + 0.056656381764 * cos(6 * z) - 0.008134974479 * cos(7 * z) + 0.00062454465 * cos(8 * z) - 0.000019808998 * cos(9 * z) + 0.000000132974 * cos(10 * z)) / N;\n      },\n      values: [],\n      correction: 1\n    }\n  };\n\n  var windowFunctions = function windowFunctions(params) {\n    if (windowCalculation[params.name].values.length !== params.N) {\n      if (params.n === 0) {\n        windowCalculation[params.name].values.length = 0;\n      }\n      windowCalculation[params.name].values[params.n] = windowCalculation[params.name].correction * windowCalculation[params.name].calc(params.n, params.N, params.a);\n      return windowCalculation[params.name].values[params.n];\n    }\n    return windowCalculation[params.name].values;\n  };\n\n  var self = {\n    forward: function forward(b, window) {\n      var i, j, n, k, k2, h, d, c, s, ik, dx, dy;\n      n = fft.buffer.length;\n      var winFunction = {\n        name: window,\n        N: n,\n        a: 0.5,\n        n: 0\n      };\n      var w = windowFunctions(winFunction);\n      if (typeof w === 'number') {\n        for (i = 0; i < n; ++i) {\n          winFunction.n = i;\n          fft.buffer[i] = b[i] * windowFunctions(winFunction);\n        }\n      } else {\n        for (i = 0; i < n; ++i) {\n          fft.buffer[i] = b[i] * w[i];\n        }\n      }\n\n      for (i = n; i--;) {\n        fft.re[i] = fft.buffer[fft.twiddle[i]];\n        fft.im[i] = 0.0;\n      }\n\n      for (k = 1; k < n; k = k2) {\n        h = 0;\n        k2 = k + k;\n        d = n / k2;\n        for (j = 0; j < k; j++) {\n          c = fft.cosTable[h];\n          s = fft.sinTable[h];\n          for (i = j; i < n; i += k2) {\n            ik = i + k;\n            dx = s * fft.im[ik] + c * fft.re[ik];\n            dy = c * fft.im[ik] - s * fft.re[ik];\n            fft.re[ik] = fft.re[i] - dx;\n            fft.re[i] += dx;\n            fft.im[ik] = fft.im[i] - dy;\n            fft.im[i] += dy;\n          }\n          h += d;\n        }\n      }\n      return {\n        re: fft.re,\n        im: fft.im\n      };\n    },\n    inverse: function inverse(re, im) {\n      var i, j, n, k, k2, h, d, c, s, ik, dx, dy;\n      n = re.length;\n      for (i = n; i--;) {\n        j = fft.twiddle[i];\n        fft.reI[i] = re[j];\n        fft.imI[i] = -im[j];\n      }\n\n      for (k = 1; k < n; k = k2) {\n        h = 0;\n        k2 = k + k;\n        d = n / k2;\n        for (j = 0; j < k; j++) {\n          c = fft.cosTable[h];\n          s = fft.sinTable[h];\n          for (i = j; i < n; i += k2) {\n            ik = i + k;\n            dx = s * fft.imI[ik] + c * fft.reI[ik];\n            dy = c * fft.imI[ik] - s * fft.reI[ik];\n            fft.reI[ik] = fft.reI[i] - dx;\n            fft.reI[i] += dx;\n            fft.imI[ik] = fft.imI[i] - dy;\n            fft.imI[i] += dy;\n          }\n          h += d;\n        }\n      }\n\n      for (i = n; i--;) {\n        fft.buffer[i] = fft.reI[i] / n;\n      }\n      return fft.buffer;\n    },\n    magnitude: function magnitude(params) {\n      var ret = [];\n      for (var cnt = 0; cnt < params.re.length; cnt++) {\n        ret.push(Math.sqrt(params.re[cnt] * params.re[cnt] + params.im[cnt] * params.im[cnt]));\n      }\n      return ret;\n    },\n    magToDb: function magToDb(b) {\n      var ret = [];\n      for (var cnt = 0; cnt < b.length; cnt++) {\n        ret.push(20 * Math.log(b[cnt]) * Math.LOG10E);\n      }\n      return ret;\n    },\n    phase: function phase(params) {\n      var ret = [];\n      for (var cnt = 0; cnt < params.re.length; cnt++) {\n        ret.push(Math.atan2(params.im[cnt], params.re[cnt]));\n      }\n      return ret;\n    },\n    windows: function windows() {\n      var winFuncs = [];\n      for (var k in windowCalculation) {\n        winFuncs.push(k);\n      }\n      return winFuncs;\n    }\n  };\n  return self;\n};\n\nmodule.exports = Fft;\n\n},{}],4:[function(require,module,exports){\n'use strict';\n\nvar FirCoeffs = function FirCoeffs() {\n  // Kaiser windowd filters\n  // desired attenuation can be defined\n  // better than windowd sinc filters\n  var calcKImpulseResponse = function calcKImpulseResponse(params) {\n    var Fs = params.Fs;\n    var Fa = params.Fa;\n    var Fb = params.Fb;\n    var o = params.order || 51;\n    var alpha = params.Att || 100;\n    var ino = function ino(val) {\n      var d = 0;\n      var ds = 1;\n      var s = 1;\n      while (ds > s * 1e-6) {\n        d += 2;\n        ds *= val * val / (d * d);\n        s += ds;\n      }\n      return s;\n    };\n\n    if (o / 2 - Math.floor(o / 2) === 0) {\n      o++;\n    }\n    var Np = (o - 1) / 2;\n    var A = [];\n    var beta = 0;\n    var cnt = 0;\n    var inoBeta;\n    var ret = [];\n\n    A[0] = 2 * (Fb - Fa) / Fs;\n    for (cnt = 1; cnt <= Np; cnt++) {\n      A[cnt] = (Math.sin(2 * cnt * Math.PI * Fb / Fs) - Math.sin(2 * cnt * Math.PI * Fa / Fs)) / (cnt * Math.PI);\n    }\n    // empirical coefficients\n    if (alpha < 21) {\n      beta = 0;\n    } else if (alpha > 50) {\n      beta = 0.1102 * (alpha - 8.7);\n    } else {\n      beta = 0.5842 * Math.pow(alpha - 21, 0.4) + 0.07886 * (alpha - 21);\n    }\n\n    inoBeta = ino(beta);\n    for (cnt = 0; cnt <= Np; cnt++) {\n      ret[Np + cnt] = A[cnt] * ino(beta * Math.sqrt(1 - cnt * cnt / (Np * Np))) / inoBeta;\n    }\n    for (cnt = 0; cnt < Np; cnt++) {\n      ret[cnt] = ret[o - 1 - cnt];\n    }\n    return ret;\n  };\n\n  // note: coefficients are equal to impulse response\n  // windowd sinc filter\n  var calcImpulseResponse = function calcImpulseResponse(params) {\n    var Fs = params.Fs;\n    var Fc = params.Fc;\n    var o = params.order;\n    var omega = 2 * Math.PI * Fc / Fs;\n    var cnt = 0;\n    var dc = 0;\n    var ret = [];\n    // sinc function is considered to be\n    // the ideal impulse response\n    // do an idft and use Hamming window afterwards\n    for (cnt = 0; cnt <= o; cnt++) {\n      if (cnt - o / 2 === 0) {\n        ret[cnt] = omega;\n      } else {\n        ret[cnt] = Math.sin(omega * (cnt - o / 2)) / (cnt - o / 2);\n        // Hamming window\n        ret[cnt] *= 0.54 - 0.46 * Math.cos(2 * Math.PI * cnt / o);\n      }\n      dc = dc + ret[cnt];\n    }\n    // normalize\n    for (cnt = 0; cnt <= o; cnt++) {\n      ret[cnt] /= dc;\n    }\n    return ret;\n  };\n  // invert for highpass from lowpass\n  var invert = function invert(h) {\n    var cnt;\n    for (cnt = 0; cnt < h.length; cnt++) {\n      h[cnt] = -h[cnt];\n    }\n    h[(h.length - 1) / 2]++;\n    return h;\n  };\n  var bs = function bs(params) {\n    var lp = calcImpulseResponse({\n      order: params.order,\n      Fs: params.Fs,\n      Fc: params.F2\n    });\n    var hp = invert(calcImpulseResponse({\n      order: params.order,\n      Fs: params.Fs,\n      Fc: params.F1\n    }));\n    var out = [];\n    for (var i = 0; i < lp.length; i++) {\n      out.push(lp[i] + hp[i]);\n    }\n    return out;\n  };\n  var self = {\n    lowpass: function lowpass(params) {\n      return calcImpulseResponse(params);\n    },\n    highpass: function highpass(params) {\n      return invert(calcImpulseResponse(params));\n    },\n    bandstop: function bandstop(params) {\n      return bs(params);\n    },\n    bandpass: function bandpass(params) {\n      return invert(bs(params));\n    },\n    kbFilter: function kbFilter(params) {\n      return calcKImpulseResponse(params);\n    },\n    available: function available() {\n      return ['lowpass', 'highpass', 'bandstop', 'bandpass', 'kbFilter'];\n    }\n  };\n  return self;\n};\n\nmodule.exports = FirCoeffs;\n\n},{}],5:[function(require,module,exports){\n'use strict';\n\nvar _require = require('./utils');\n\nvar runMultiFilter = _require.runMultiFilter;\nvar runMultiFilterReverse = _require.runMultiFilterReverse;\nvar complex = _require.complex;\nvar evaluatePhase = _require.evaluatePhase;\n\n/**\n * Fir filter\n */\nvar FirFilter = function FirFilter(filter) {\n  // note: coefficients are equal to input response\n  var f = filter;\n  var b = [];\n  var cnt = 0;\n  for (cnt = 0; cnt < f.length; cnt++) {\n    b[cnt] = {\n      re: f[cnt],\n      im: 0\n    };\n  }\n\n  var initZero = function initZero(cnt) {\n    var r = [];\n    var i;\n    for (i = 0; i < cnt; i++) {\n      r.push(0);\n    }\n    return {\n      buf: r,\n      pointer: 0\n    };\n  };\n\n  var z = initZero(f.length - 1);\n\n  var doStep = function doStep(input, d) {\n    d.buf[d.pointer] = input;\n    var out = 0;\n    for (cnt = 0; cnt < d.buf.length; cnt++) {\n      out += f[cnt] * d.buf[(d.pointer + cnt) % d.buf.length];\n    }\n    d.pointer = (d.pointer + 1) % d.buf.length;\n    return out;\n  };\n\n  var calcInputResponse = function calcInputResponse(input) {\n    var tempF = initZero(f.length - 1);\n    return runMultiFilter(input, tempF, doStep);\n  };\n\n  var calcResponse = function calcResponse(params) {\n    var Fs = params.Fs;\n    var Fr = params.Fr;\n    // z = exp(j*omega*pi) = cos(omega*pi) + j*sin(omega*pi)\n    // z^-1 = exp(-j*omega*pi)\n    // omega is between 0 and 1. 1 is the Nyquist frequency.\n    var theta = -Math.PI * (Fr / Fs) * 2;\n    var h = {\n      re: 0,\n      im: 0\n    };\n    for (var i = 0; i < f.length - 1; i++) {\n      h = complex.add(h, complex.mul(b[i], {\n        re: Math.cos(theta * i),\n        im: Math.sin(theta * i)\n      }));\n    }\n    var m = complex.magnitude(h);\n    var res = {\n      magnitude: m,\n      phase: complex.phase(h),\n      dBmagnitude: 20 * Math.log(m) * Math.LOG10E\n    };\n    return res;\n  };\n\n  var self = {\n    responsePoint: function responsePoint(params) {\n      return calcResponse(params);\n    },\n    response: function response(resolution) {\n      resolution = resolution || 100;\n      var res = [];\n      var cnt = 0;\n      var r = resolution * 2;\n      for (cnt = 0; cnt < resolution; cnt++) {\n        res[cnt] = calcResponse({\n          Fs: r,\n          Fr: cnt\n        });\n      }\n      evaluatePhase(res);\n      return res;\n    },\n    simulate: function simulate(input) {\n      return calcInputResponse(input);\n    },\n    singleStep: function singleStep(input) {\n      return doStep(input, z);\n    },\n    multiStep: function multiStep(input, overwrite) {\n      return runMultiFilter(input, z, doStep, overwrite);\n    },\n    filtfilt: function filtfilt(input, overwrite) {\n      return runMultiFilterReverse(runMultiFilter(input, z, doStep, overwrite), z, doStep, true);\n    },\n    reinit: function reinit() {\n      z = initZero(f.length - 1);\n    }\n  };\n  return self;\n};\n\nmodule.exports = FirFilter;\n\n},{\"./utils\":9}],6:[function(require,module,exports){\n'use strict';\n\nvar IirCoeffs = function IirCoeffs() {\n  var preCalc = function preCalc(params, coeffs) {\n    var Q = params.Q;\n    var Fc = params.Fc;\n    var Fs = params.Fs;\n    var pre = {};\n    var w = 2 * Math.PI * Fc / Fs;\n    if (params.BW) {\n      pre.alpha = Math.sin(w) * Math.sinh(Math.log(2) / 2 * params.BW * w / Math.sin(w));\n    } else {\n      pre.alpha = Math.sin(w) / (2 * Q);\n    }\n    pre.cw = Math.cos(w);\n    pre.a0 = 1 + pre.alpha;\n    coeffs.a0 = pre.a0;\n    coeffs.a.push(-2 * pre.cw / pre.a0);\n    coeffs.k = 1;\n    coeffs.a.push((1 - pre.alpha) / pre.a0);\n    return pre;\n  };\n\n  var preCalcGain = function preCalcGain(params) {\n    var Q = params.Q;\n    var Fc = params.Fc;\n    var Fs = params.Fs;\n    var pre = {};\n    var w = 2 * Math.PI * Fc / Fs;\n    pre.alpha = Math.sin(w) / (2 * Q);\n    pre.cw = Math.cos(w);\n    pre.A = Math.pow(10, params.gain / 40);\n    return pre;\n  };\n\n  var initCoeffs = function initCoeffs() {\n    var coeffs = {};\n    coeffs.z = [0, 0];\n    coeffs.a = [];\n    coeffs.b = [];\n    return coeffs;\n  };\n\n  var self = {\n\n    fromPZ: function fromPZ(params) {\n      var coeffs = initCoeffs();\n      coeffs.a0 = 1;\n      coeffs.b.push(1);\n      coeffs.b.push(-params.z0.re - params.z1.re);\n      coeffs.b.push(params.z0.re * params.z1.re - params.z0.im * params.z1.im);\n      coeffs.a.push(-params.p0.re - params.p1.re);\n      coeffs.a.push(params.p0.re * params.p1.re - params.p0.im * params.p1.im);\n      if (params.type === 'lowpass') {\n        coeffs.k = (1 + coeffs.a[0] + coeffs.a[1]) / (1 + coeffs.b[1] + coeffs.b[2]);\n      } else {\n        coeffs.k = (1 - coeffs.a[0] + coeffs.a[1]) / (1 - coeffs.b[1] + coeffs.b[2]);\n      }\n      return coeffs;\n    },\n\n    // lowpass matched-z transform: H(s) = 1/(1+a's/w_c+b's^2/w_c)\n    lowpassMZ: function lowpassMZ(params) {\n      var coeffs = initCoeffs();\n      coeffs.a0 = 1;\n      var as = params.as;\n      var bs = params.bs;\n      var w = 2 * Math.PI * params.Fc / params.Fs;\n      var s = -(as / (2 * bs));\n      coeffs.a.push(-Math.pow(Math.E, s * w) * 2 * Math.cos(-w * Math.sqrt(Math.abs(Math.pow(as, 2) / (4 * Math.pow(bs, 2)) - 1 / bs))));\n      coeffs.a.push(Math.pow(Math.E, 2 * s * w));\n      // correct gain\n      if (!params.preGain) {\n        coeffs.b.push(coeffs.a0 + coeffs.a[0] + coeffs.a[1]);\n        coeffs.k = 1;\n      } else {\n        coeffs.b.push(1);\n        coeffs.k = coeffs.a0 + coeffs.a[0] + coeffs.a[1];\n      }\n      coeffs.b.push(0);\n      coeffs.b.push(0);\n      return coeffs;\n    },\n\n    // Bessel-Thomson: H(s) = 3/(s^2+3*s+3)\n    lowpassBT: function lowpassBT(params) {\n      var coeffs = initCoeffs();\n      params.Q = 1;\n      coeffs.wp = Math.tan(2 * Math.PI * params.Fc / (2 * params.Fs));\n      coeffs.wp2 = coeffs.wp * coeffs.wp;\n      if (params.BW) {\n        delete params.BW;\n      }\n      coeffs.k = 1;\n      coeffs.a0 = 3 * coeffs.wp + 3 * coeffs.wp2 + 1;\n      coeffs.b.push(3 * coeffs.wp2 * params.Q / coeffs.a0);\n      coeffs.b.push(2 * coeffs.b[0]);\n      coeffs.b.push(coeffs.b[0]);\n      coeffs.a.push((6 * coeffs.wp2 - 2) / coeffs.a0);\n      coeffs.a.push((3 * coeffs.wp2 - 3 * coeffs.wp + 1) / coeffs.a0);\n      return coeffs;\n    },\n\n    highpassBT: function highpassBT(params) {\n      var coeffs = initCoeffs();\n      params.Q = 1;\n      coeffs.wp = Math.tan(2 * Math.PI * params.Fc / (2 * params.Fs));\n      coeffs.wp2 = coeffs.wp * coeffs.wp;\n      if (params.BW) {\n        delete params.BW;\n      }\n      coeffs.k = 1;\n      coeffs.a0 = coeffs.wp + coeffs.wp2 + 3;\n      coeffs.b.push(3 * params.Q / coeffs.a0);\n      coeffs.b.push(2 * coeffs.b[0]);\n      coeffs.b.push(coeffs.b[0]);\n      coeffs.a.push((2 * coeffs.wp2 - 6) / coeffs.a0);\n      coeffs.a.push((coeffs.wp2 - coeffs.wp + 3) / coeffs.a0);\n      return coeffs;\n    },\n\n    /*\n     * Formulas from http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt\n     */\n    // H(s) = 1 / (s^2 + s/Q + 1)\n    lowpass: function lowpass(params) {\n      var coeffs = initCoeffs();\n      if (params.BW) {\n        delete params.BW;\n      }\n      var p = preCalc(params, coeffs);\n      if (params.preGain) {\n        coeffs.k = (1 - p.cw) * 0.5;\n        coeffs.b.push(1 / p.a0);\n      } else {\n        coeffs.k = 1;\n        coeffs.b.push((1 - p.cw) / (2 * p.a0));\n      }\n      coeffs.b.push(2 * coeffs.b[0]);\n      coeffs.b.push(coeffs.b[0]);\n      return coeffs;\n    },\n\n    // H(s) = s^2 / (s^2 + s/Q + 1)\n    highpass: function highpass(params) {\n      var coeffs = initCoeffs();\n      if (params.BW) {\n        delete params.BW;\n      }\n      var p = preCalc(params, coeffs);\n      if (params.preGain) {\n        coeffs.k = (1 + p.cw) * 0.5;\n        coeffs.b.push(1 / p.a0);\n      } else {\n        coeffs.k = 1;\n        coeffs.b.push((1 + p.cw) / (2 * p.a0));\n      }\n      coeffs.b.push(-2 * coeffs.b[0]);\n      coeffs.b.push(coeffs.b[0]);\n      return coeffs;\n    },\n\n    // H(s) = (s^2 - s/Q + 1) / (s^2 + s/Q + 1)\n    allpass: function allpass(params) {\n      var coeffs = initCoeffs();\n      if (params.BW) {\n        delete params.BW;\n      }\n      var p = preCalc(params, coeffs);\n      coeffs.k = 1;\n      coeffs.b.push((1 - p.alpha) / p.a0);\n      coeffs.b.push(-2 * p.cw / p.a0);\n      coeffs.b.push((1 + p.alpha) / p.a0);\n      return coeffs;\n    },\n\n    // H(s) = s / (s^2 + s/Q + 1)\n    bandpassQ: function bandpassQ(params) {\n      var coeffs = initCoeffs();\n      var p = preCalc(params, coeffs);\n      coeffs.k = 1;\n      coeffs.b.push(p.alpha * params.Q / p.a0);\n      coeffs.b.push(0);\n      coeffs.b.push(-coeffs.b[0]);\n      return coeffs;\n    },\n\n    // H(s) = (s/Q) / (s^2 + s/Q + 1)\n    bandpass: function bandpass(params) {\n      var coeffs = initCoeffs();\n      var p = preCalc(params, coeffs);\n      coeffs.k = 1;\n      coeffs.b.push(p.alpha / p.a0);\n      coeffs.b.push(0);\n      coeffs.b.push(-coeffs.b[0]);\n      return coeffs;\n    },\n\n    // H(s) = (s^2 + 1) / (s^2 + s/Q + 1)\n    bandstop: function bandstop(params) {\n      var coeffs = initCoeffs();\n      var p = preCalc(params, coeffs);\n      coeffs.k = 1;\n      coeffs.b.push(1 / p.a0);\n      coeffs.b.push(-2 * p.cw / p.a0);\n      coeffs.b.push(coeffs.b[0]);\n      return coeffs;\n    },\n\n    // H(s) = (s^2 + s*(A/Q) + 1) / (s^2 + s/(A*Q) + 1)\n    peak: function peak(params) {\n      var coeffs = initCoeffs();\n      var p = preCalcGain(params);\n      coeffs.k = 1;\n      coeffs.a0 = 1 + p.alpha / p.A;\n      coeffs.a.push(-2 * p.cw / coeffs.a0);\n      coeffs.a.push((1 - p.alpha / p.A) / coeffs.a0);\n      coeffs.b.push((1 + p.alpha * p.A) / coeffs.a0);\n      coeffs.b.push(-2 * p.cw / coeffs.a0);\n      coeffs.b.push((1 - p.alpha * p.A) / coeffs.a0);\n      return coeffs;\n    },\n\n    // H(s) = A * (s^2 + (sqrt(A)/Q)*s + A)/(A*s^2 + (sqrt(A)/Q)*s + 1)\n    lowshelf: function lowshelf(params) {\n      var coeffs = initCoeffs();\n      if (params.BW) {\n        delete params.BW;\n      }\n      var p = preCalcGain(params);\n      coeffs.k = 1;\n      var sa = 2 * Math.sqrt(p.A) * p.alpha;\n      coeffs.a0 = p.A + 1 + (p.A - 1) * p.cw + sa;\n      coeffs.a.push(-2 * (p.A - 1 + (p.A + 1) * p.cw) / coeffs.a0);\n      coeffs.a.push((p.A + 1 + (p.A - 1) * p.cw - sa) / coeffs.a0);\n      coeffs.b.push(p.A * (p.A + 1 - (p.A - 1) * p.cw + sa) / coeffs.a0);\n      coeffs.b.push(2 * p.A * (p.A - 1 - (p.A + 1) * p.cw) / coeffs.a0);\n      coeffs.b.push(p.A * (p.A + 1 - (p.A - 1) * p.cw - sa) / coeffs.a0);\n      return coeffs;\n    },\n\n    // H(s) = A * (A*s^2 + (sqrt(A)/Q)*s + 1)/(s^2 + (sqrt(A)/Q)*s + A)\n    highshelf: function highshelf(params) {\n      var coeffs = initCoeffs();\n      if (params.BW) {\n        delete params.BW;\n      }\n      var p = preCalcGain(params);\n      coeffs.k = 1;\n      var sa = 2 * Math.sqrt(p.A) * p.alpha;\n      coeffs.a0 = p.A + 1 - (p.A - 1) * p.cw + sa;\n      coeffs.a.push(2 * (p.A - 1 - (p.A + 1) * p.cw) / coeffs.a0);\n      coeffs.a.push((p.A + 1 - (p.A - 1) * p.cw - sa) / coeffs.a0);\n      coeffs.b.push(p.A * (p.A + 1 + (p.A - 1) * p.cw + sa) / coeffs.a0);\n      coeffs.b.push(-2 * p.A * (p.A - 1 + (p.A + 1) * p.cw) / coeffs.a0);\n      coeffs.b.push(p.A * (p.A + 1 + (p.A - 1) * p.cw - sa) / coeffs.a0);\n      return coeffs;\n    },\n\n    // taken from: Design of digital filters for frequency weightings (A and C) required for risk assessments of workers exposed to noise\n    // use Butterworth one stage IIR filter to get the results from the paper\n    aweighting: function aweighting(params) {\n      var coeffs = initCoeffs();\n      coeffs.k = 1;\n      var wo = 2 * Math.PI * params.Fc / params.Fs;\n      var w = 2 * Math.tan(wo / 2);\n      var Q = params.Q;\n      var wsq = Math.pow(w, 2);\n      coeffs.a0 = 4 * Q + wsq * Q + 2 * w;\n      coeffs.a.push(2 * wsq * Q - 8 * Q);\n      coeffs.a.push(4 * Q + wsq * Q - 2 * w);\n      coeffs.b.push(wsq * Q);\n      coeffs.b.push(2 * wsq * Q);\n      coeffs.b.push(wsq * Q);\n      return coeffs;\n    }\n  };\n\n  return self;\n};\n\nmodule.exports = IirCoeffs;\n\n},{}],7:[function(require,module,exports){\n'use strict';\n\nvar _require = require('./utils');\n\nvar complex = _require.complex;\nvar runMultiFilter = _require.runMultiFilter;\nvar runMultiFilterReverse = _require.runMultiFilterReverse;\nvar evaluatePhase = _require.evaluatePhase;\n\n// params: array of biquad coefficient objects and z registers\n// stage structure e.g. {k:1, a:[1.1, -1.2], b:[0.3, -1.2, -0.4], z:[0, 0]}\nvar IirFilter = function IirFilter(filter) {\n  var f = filter;\n  var cone = {\n    re: 1,\n    im: 0\n  };\n  var cf = [];\n  var cc = [];\n  for (var cnt = 0; cnt < f.length; cnt++) {\n    cf[cnt] = {};\n    var s = f[cnt];\n    cf[cnt].b0 = {\n      re: s.b[0],\n      im: 0\n    };\n    cf[cnt].b1 = {\n      re: s.b[1],\n      im: 0\n    };\n    cf[cnt].b2 = {\n      re: s.b[2],\n      im: 0\n    };\n    cf[cnt].a1 = {\n      re: s.a[0],\n      im: 0\n    };\n    cf[cnt].a2 = {\n      re: s.a[1],\n      im: 0\n    };\n    cf[cnt].k = {\n      re: s.k,\n      im: 0\n    };\n    cf[cnt].z = [0, 0];\n    cc[cnt] = {};\n    cc[cnt].b1 = s.b[1] / s.b[0];\n    cc[cnt].b2 = s.b[2] / s.b[0];\n    cc[cnt].a1 = s.a[0];\n    cc[cnt].a2 = s.a[1];\n  }\n\n  var runStage = function runStage(s, input) {\n    var temp = input * s.k.re - s.a1.re * s.z[0] - s.a2.re * s.z[1];\n    var out = s.b0.re * temp + s.b1.re * s.z[0] + s.b2.re * s.z[1];\n    s.z[1] = s.z[0];\n    s.z[0] = temp;\n    return out;\n  };\n\n  var doStep = function doStep(input, coeffs) {\n    var out = input;\n    var cnt = 0;\n    for (cnt = 0; cnt < coeffs.length; cnt++) {\n      out = runStage(coeffs[cnt], out);\n    }\n    return out;\n  };\n\n  var biquadResponse = function biquadResponse(params, s) {\n    var Fs = params.Fs;\n    var Fr = params.Fr;\n    // z = exp(j*omega*pi) = cos(omega*pi) + j*sin(omega*pi)\n    // z^-1 = exp(-j*omega*pi)\n    // omega is between 0 and 1. 1 is the Nyquist frequency.\n    var theta = -Math.PI * (Fr / Fs) * 2;\n    var z = {\n      re: Math.cos(theta),\n      im: Math.sin(theta)\n    };\n    // k * (b0 + b1*z^-1 + b2*z^-2) / (1 + a1*z^1 + a2*z^-2)\n    var p = complex.mul(s.k, complex.add(s.b0, complex.mul(z, complex.add(s.b1, complex.mul(s.b2, z)))));\n    var q = complex.add(cone, complex.mul(z, complex.add(s.a1, complex.mul(s.a2, z))));\n    var h = complex.div(p, q);\n    var res = {\n      magnitude: complex.magnitude(h),\n      phase: complex.phase(h)\n    };\n    return res;\n  };\n\n  var calcResponse = function calcResponse(params) {\n    var cnt = 0;\n    var res = {\n      magnitude: 1,\n      phase: 0\n    };\n    for (cnt = 0; cnt < cf.length; cnt++) {\n      var r = biquadResponse(params, cf[cnt]);\n      // a cascade of biquads results in the multiplication of H(z)\n      // H_casc(z) = H_0(z) * H_1(z) * ... * H_n(z)\n      res.magnitude *= r.magnitude;\n      // phase is wrapped -> unwrap before using\n      res.phase += r.phase;\n    }\n    res.dBmagnitude = 20 * Math.log(res.magnitude) * Math.LOG10E;\n    return res;\n  };\n\n  var reinit = function reinit() {\n    var tempF = [];\n    for (var cnt = 0; cnt < f.length; cnt++) {\n      tempF[cnt] = {\n        b0: {\n          re: s.b[0],\n          im: 0\n        },\n        b1: {\n          re: s.b[1],\n          im: 0\n        },\n        b2: {\n          re: s.b[2],\n          im: 0\n        },\n        a1: {\n          re: s.a[0],\n          im: 0\n        },\n        a2: {\n          re: s.a[1],\n          im: 0\n        },\n        k: {\n          re: s.k,\n          im: 0\n        },\n        z: [0, 0]\n      };\n    }\n    return tempF;\n  };\n\n  var calcInputResponse = function calcInputResponse(input) {\n    var tempF = reinit();\n    return runMultiFilter(input, tempF, doStep);\n  };\n\n  var predefinedResponse = function predefinedResponse(def, length) {\n    var ret = {};\n    var input = [];\n    var cnt = 0;\n    for (cnt = 0; cnt < length; cnt++) {\n      input.push(def(cnt));\n    }\n    ret.out = calcInputResponse(input);\n    var maxFound = false;\n    var minFound = false;\n    for (cnt = 0; cnt < length - 1; cnt++) {\n      if (ret.out[cnt] > ret.out[cnt + 1] && !maxFound) {\n        maxFound = true;\n        ret.max = {\n          sample: cnt,\n          value: ret.out[cnt]\n        };\n      }\n      if (maxFound && !minFound && ret.out[cnt] < ret.out[cnt + 1]) {\n        minFound = true;\n        ret.min = {\n          sample: cnt,\n          value: ret.out[cnt]\n        };\n        break;\n      }\n    }\n    return ret;\n  };\n\n  var getComplRes = function getComplRes(n1, n2) {\n    var innerSqrt = Math.pow(n1 / 2, 2) - n2;\n    if (innerSqrt < 0) {\n      return [{\n        re: -n1 / 2,\n        im: Math.sqrt(Math.abs(innerSqrt))\n      }, {\n        re: -n1 / 2,\n        im: -Math.sqrt(Math.abs(innerSqrt))\n      }];\n    } else {\n      return [{\n        re: -n1 / 2 + Math.sqrt(innerSqrt),\n        im: 0\n      }, {\n        re: -n1 / 2 - Math.sqrt(innerSqrt),\n        im: 0\n      }];\n    }\n  };\n\n  var getPZ = function getPZ() {\n    var res = [];\n    for (var cnt = 0; cnt < cc.length; cnt++) {\n      res[cnt] = {};\n      res[cnt].z = getComplRes(cc[cnt].b1, cc[cnt].b2);\n      res[cnt].p = getComplRes(cc[cnt].a1, cc[cnt].a2);\n    }\n    return res;\n  };\n\n  var self = {\n    singleStep: function singleStep(input) {\n      return doStep(input, cf);\n    },\n    multiStep: function multiStep(input, overwrite) {\n      return runMultiFilter(input, cf, doStep, overwrite);\n    },\n    filtfilt: function filtfilt(input, overwrite) {\n      return runMultiFilterReverse(runMultiFilter(input, cf, doStep, overwrite), cf, doStep, true);\n    },\n    simulate: function simulate(input) {\n      return calcInputResponse(input);\n    },\n    stepResponse: function stepResponse(length) {\n      return predefinedResponse(function () {\n        return 1;\n      }, length);\n    },\n    impulseResponse: function impulseResponse(length) {\n      return predefinedResponse(function (val) {\n        if (val === 0) {\n          return 1;\n        } else {\n          return 0;\n        }\n      }, length);\n    },\n    responsePoint: function responsePoint(params) {\n      return calcResponse(params);\n    },\n    response: function response(resolution) {\n      resolution = resolution || 100;\n      var res = [];\n      var cnt = 0;\n      var r = resolution * 2;\n      for (cnt = 0; cnt < resolution; cnt++) {\n        res[cnt] = calcResponse({\n          Fs: r,\n          Fr: cnt\n        });\n      }\n      evaluatePhase(res);\n      return res;\n    },\n    polesZeros: function polesZeros() {\n      return getPZ();\n    },\n    reinit: function reinit() {\n      for (cnt = 0; cnt < cf.length; cnt++) {\n        cf[cnt].z = [0, 0];\n      }\n    }\n  };\n  return self;\n};\n\nmodule.exports = IirFilter;\n\n},{\"./utils\":9}],8:[function(require,module,exports){\n'use strict';\n\n/**\n * Test filter\n */\nvar TestFilter = function TestFilter(filter) {\n  var f = filter;\n\n  var simData = [];\n  var cnt;\n\n  var randomValues = function randomValues(params) {\n    for (cnt = 0; cnt < params.steps; cnt++) {\n      simData.push(f.singleStep((Math.random() - 0.5) * params.pp + params.offset));\n    }\n  };\n\n  var stepValues = function stepValues(params) {\n    var max = params.offset + params.pp;\n    var min = params.offset - params.pp;\n    for (cnt = 0; cnt < params.steps; cnt++) {\n      if (cnt % 200 < 100) {\n        simData.push(f.singleStep(max));\n      } else {\n        simData.push(f.singleStep(min));\n      }\n    }\n  };\n\n  var impulseValues = function impulseValues(params) {\n    var max = params.offset + params.pp;\n    var min = params.offset - params.pp;\n    for (cnt = 0; cnt < params.steps; cnt++) {\n      if (cnt % 100 === 0) {\n        simData.push(f.singleStep(max));\n      } else {\n        simData.push(f.singleStep(min));\n      }\n    }\n  };\n\n  var rampValues = function rampValues(params) {\n    var max = params.offset + params.pp;\n    var min = params.offset - params.pp;\n    var val = min;\n    var diff = (max - min) / 100;\n    for (cnt = 0; cnt < params.steps; cnt++) {\n      if (cnt % 200 < 100) {\n        val += diff;\n      } else {\n        val -= diff;\n      }\n      simData.push(f.singleStep(val));\n    }\n  };\n\n  var self = {\n    randomStability: function randomStability(params) {\n      f.reinit();\n      simData.length = 0;\n      randomValues(params);\n      for (cnt = params.setup; cnt < simData.length; cnt++) {\n        if (simData[cnt] > params.maxStable || simData[cnt] < params.minStable) {\n          return simData[cnt];\n        }\n      }\n      return true;\n    },\n    directedRandomStability: function directedRandomStability(params) {\n      f.reinit();\n      simData.length = 0;\n      var i;\n      for (i = 0; i < params.tests; i++) {\n        var choose = Math.random();\n        if (choose < 0.25) {\n          randomValues(params);\n        } else if (choose < 0.5) {\n          stepValues(params);\n        } else if (choose < 0.75) {\n          impulseValues(params);\n        } else {\n          rampValues(params);\n        }\n      }\n      randomValues(params);\n      for (cnt = params.setup; cnt < simData.length; cnt++) {\n        if (simData[cnt] > params.maxStable || simData[cnt] < params.minStable) {\n          return simData[cnt];\n        }\n      }\n      return true;\n    },\n    evaluateBehavior: function evaluateBehavior() {}\n  };\n  return self;\n};\n\nmodule.exports = TestFilter;\n\n},{}],9:[function(require,module,exports){\n'use strict';\n\n/**\n * Evaluate phase\n */\nexports.evaluatePhase = function (res) {\n  var xcnt = 0;\n  var cnt = 0;\n  var pi = Math.PI;\n  var tpi = 2 * pi;\n  var phase = [];\n  for (cnt = 0; cnt < res.length; cnt++) {\n    phase.push(res[cnt].phase);\n  }\n  res[0].unwrappedPhase = res[0].phase;\n  res[0].groupDelay = 0;\n  // TODO: more sophisticated phase unwrapping needed\n  for (cnt = 1; cnt < phase.length; cnt++) {\n    var diff = phase[cnt] - phase[cnt - 1];\n    if (diff > pi) {\n      for (xcnt = cnt; xcnt < phase.length; xcnt++) {\n        phase[xcnt] -= tpi;\n      }\n    } else if (diff < -pi) {\n      for (xcnt = cnt; xcnt < phase.length; xcnt++) {\n        phase[xcnt] += tpi;\n      }\n    }\n    if (phase[cnt] < 0) {\n      res[cnt].unwrappedPhase = -phase[cnt];\n    } else {\n      res[cnt].unwrappedPhase = phase[cnt];\n    }\n\n    res[cnt].phaseDelay = res[cnt].unwrappedPhase / (cnt / res.length);\n    res[cnt].groupDelay = (res[cnt].unwrappedPhase - res[cnt - 1].unwrappedPhase) / (pi / res.length);\n    if (res[cnt].groupDelay < 0) {\n      res[cnt].groupDelay = -res[cnt].groupDelay;\n    }\n  }\n  if (res[0].magnitude !== 0) {\n    res[0].phaseDelay = res[1].phaseDelay;\n    res[0].groupDelay = res[1].groupDelay;\n  } else {\n    res[0].phaseDelay = res[2].phaseDelay;\n    res[0].groupDelay = res[2].groupDelay;\n    res[1].phaseDelay = res[2].phaseDelay;\n    res[1].groupDelay = res[2].groupDelay;\n  }\n};\n\n/**\n * Run multi filter\n */\nexports.runMultiFilter = function (input, d, doStep, overwrite) {\n  var out = [];\n  if (overwrite) {\n    out = input;\n  }\n  var i;\n  for (i = 0; i < input.length; i++) {\n    out[i] = doStep(input[i], d);\n  }\n  return out;\n};\n\nexports.runMultiFilterReverse = function (input, d, doStep, overwrite) {\n  var out = [];\n  if (overwrite) {\n    out = input;\n  }\n  var i;\n  for (i = input.length - 1; i >= 0; i--) {\n    out[i] = doStep(input[i], d);\n  }\n  return out;\n};\n\nvar factorial = function factorial(_x, _x2) {\n  var _again = true;\n\n  _function: while (_again) {\n    var n = _x,\n        a = _x2;\n    _again = false;\n\n    if (!a) {\n      a = 1;\n    }\n    if (n !== Math.floor(n) || a !== Math.floor(a)) {\n      return 1;\n    }\n    if (n === 0 || n === 1) {\n      return a;\n    } else {\n      _x = n - 1;\n      _x2 = a * n;\n      _again = true;\n      continue _function;\n    }\n  }\n};\n\n/**\n * Bessel factors\n */\nexports.besselFactors = function (n) {\n  var res = [];\n  for (var k = 0; k < n + 1; k++) {\n    var p = factorial(2 * n - k);\n    var q = Math.pow(2, n - k) * factorial(k) * factorial(n - k);\n    res.unshift(Math.floor(p / q));\n  }\n  return res;\n};\n\nvar fractionToFp = function fractionToFp(fraction, fractionBits) {\n  var fpFraction = 0;\n  for (var cnt = 0; cnt < fractionBits; cnt++) {\n    var bitVal = 1 / Math.pow(2, cnt + 1);\n    if (fraction > bitVal) {\n      fraction -= bitVal;\n      fpFraction += bitVal;\n    }\n  }\n  return fpFraction;\n};\n\nvar numberToFp = function numberToFp(number, numberBits) {\n  return number & Math.pow(2, numberBits);\n};\n\nvar valueToFp = function valueToFp(value, numberBits, fractionBits) {\n  var number = Math.abs(value);\n  var fraction = value - number;\n  var fpNumber = {\n    number: numberToFp(number, numberBits).toString(),\n    fraction: fractionToFp(fraction, fractionBits).toString(),\n    numberBits: numberBits,\n    fractionBits: fractionBits\n  };\n  return fpNumber;\n};\n\nexports.fixedPoint = {\n  convert: function convert(value, numberBits, fractionBits) {\n    return valueToFp(value, numberBits, fractionBits);\n  },\n  add: function add(fpVal1, fpVal2) {},\n  sub: function sub(fpVal1, fpVal2) {},\n  mul: function mul(fpVal1, fpVal2) {},\n  div: function div(fpVal1, fpVal2) {}\n};\n\n/**\n * Complex\n */\nexports.complex = {\n\n  div: function div(p, q) {\n    var a = p.re;\n    var b = p.im;\n    var c = q.re;\n    var d = q.im;\n    var n = c * c + d * d;\n    var x = {\n      re: (a * c + b * d) / n,\n      im: (b * c - a * d) / n\n    };\n    return x;\n  },\n  mul: function mul(p, q) {\n    var a = p.re;\n    var b = p.im;\n    var c = q.re;\n    var d = q.im;\n    var x = {\n      re: a * c - b * d,\n      im: (a + b) * (c + d) - a * c - b * d\n    };\n    return x;\n  },\n  add: function add(p, q) {\n    var x = {\n      re: p.re + q.re,\n      im: p.im + q.im\n    };\n    return x;\n  },\n  sub: function sub(p, q) {\n    var x = {\n      re: p.re - q.re,\n      im: p.im - q.im\n    };\n    return x;\n  },\n  phase: function phase(n) {\n    return Math.atan2(n.im, n.re);\n  },\n  magnitude: function magnitude(n) {\n    return Math.sqrt(n.re * n.re + n.im * n.im);\n  }\n};\n\n},{}]},{},[1])(1)\n});\n",["143","144"],"C:\\Users\\Thomas\\grain\\src\\Animator.js",[],"C:\\Users\\Thomas\\grain\\src\\useWindowSize.js",[],{"ruleId":"145","replacedBy":"146"},{"ruleId":"147","replacedBy":"148"},{"ruleId":"145","replacedBy":"149"},{"ruleId":"147","replacedBy":"150"},{"ruleId":"151","severity":1,"message":"152","line":16,"column":8,"nodeType":"153","messageId":"154","endLine":16,"endColumn":21},{"ruleId":"151","severity":1,"message":"155","line":18,"column":8,"nodeType":"153","messageId":"154","endLine":18,"endColumn":11},{"ruleId":"151","severity":1,"message":"156","line":19,"column":9,"nodeType":"153","messageId":"154","endLine":19,"endColumn":11},{"ruleId":"151","severity":1,"message":"157","line":19,"column":13,"nodeType":"153","messageId":"154","endLine":19,"endColumn":16},{"ruleId":"151","severity":1,"message":"158","line":19,"column":23,"nodeType":"153","messageId":"154","endLine":19,"endColumn":26},{"ruleId":"151","severity":1,"message":"159","line":19,"column":28,"nodeType":"153","messageId":"154","endLine":19,"endColumn":31},{"ruleId":"151","severity":1,"message":"160","line":20,"column":8,"nodeType":"153","messageId":"154","endLine":20,"endColumn":13},{"ruleId":"151","severity":1,"message":"161","line":42,"column":9,"nodeType":"153","messageId":"154","endLine":42,"endColumn":18},{"ruleId":"151","severity":1,"message":"162","line":43,"column":9,"nodeType":"153","messageId":"154","endLine":43,"endColumn":18},{"ruleId":"151","severity":1,"message":"163","line":44,"column":9,"nodeType":"153","messageId":"154","endLine":44,"endColumn":18},{"ruleId":"151","severity":1,"message":"164","line":45,"column":9,"nodeType":"153","messageId":"154","endLine":45,"endColumn":18},{"ruleId":"151","severity":1,"message":"165","line":49,"column":10,"nodeType":"153","messageId":"154","endLine":49,"endColumn":21},{"ruleId":"151","severity":1,"message":"166","line":49,"column":23,"nodeType":"153","messageId":"154","endLine":49,"endColumn":37},{"ruleId":"151","severity":1,"message":"167","line":51,"column":18,"nodeType":"153","messageId":"154","endLine":51,"endColumn":27},{"ruleId":"168","severity":1,"message":"169","line":75,"column":6,"nodeType":"170","endLine":75,"endColumn":8,"suggestions":"171"},{"ruleId":"168","severity":1,"message":"172","line":78,"column":3,"nodeType":"153","endLine":78,"endColumn":12,"suggestions":"173"},{"ruleId":"174","severity":1,"message":"175","line":117,"column":18,"nodeType":"176","messageId":"177","endLine":117,"endColumn":20},{"ruleId":"174","severity":1,"message":"175","line":126,"column":18,"nodeType":"176","messageId":"177","endLine":126,"endColumn":20},{"ruleId":"178","severity":1,"message":"179","line":180,"column":14,"nodeType":"153","messageId":"180","endLine":180,"endColumn":15},{"ruleId":"178","severity":1,"message":"179","line":199,"column":14,"nodeType":"153","messageId":"180","endLine":199,"endColumn":15},{"ruleId":"151","severity":1,"message":"181","line":224,"column":12,"nodeType":"153","messageId":"154","endLine":224,"endColumn":18},{"ruleId":"151","severity":1,"message":"182","line":12,"column":31,"nodeType":"153","messageId":"154","endLine":12,"endColumn":53},{"ruleId":"151","severity":1,"message":"183","line":33,"column":9,"nodeType":"153","messageId":"154","endLine":33,"endColumn":23},{"ruleId":"151","severity":1,"message":"184","line":40,"column":9,"nodeType":"153","messageId":"154","endLine":40,"endColumn":24},{"ruleId":"151","severity":1,"message":"185","line":5,"column":17,"nodeType":"153","messageId":"154","endLine":5,"endColumn":26},{"ruleId":"186","severity":1,"message":"187","line":2,"column":5,"nodeType":"188","messageId":"189","endLine":2,"endColumn":18,"fix":"190"},{"ruleId":"174","severity":1,"message":"175","line":15,"column":11,"nodeType":"176","messageId":"177","endLine":15,"endColumn":13},{"ruleId":"145","replacedBy":"191"},{"ruleId":"147","replacedBy":"192"},{"ruleId":"186","severity":1,"message":"187","line":23,"column":2,"nodeType":"188","messageId":"189","endLine":23,"endColumn":15,"fix":"193"},{"ruleId":"151","severity":1,"message":"185","line":3,"column":17,"nodeType":"153","messageId":"154","endLine":3,"endColumn":26},{"ruleId":"145","replacedBy":"194"},{"ruleId":"147","replacedBy":"195"},{"ruleId":"196","severity":2,"message":"197","line":7,"column":128,"nodeType":"153","messageId":"198","endLine":7,"endColumn":134},{"ruleId":"196","severity":2,"message":"197","line":7,"column":140,"nodeType":"153","messageId":"198","endLine":7,"endColumn":146},{"ruleId":"199","severity":2,"message":"200","line":7,"column":266,"nodeType":"153","messageId":"201","endLine":7,"endColumn":270},{"ruleId":"199","severity":2,"message":"200","line":7,"column":288,"nodeType":"153","messageId":"201","endLine":7,"endColumn":292},{"ruleId":"151","severity":1,"message":"202","line":7,"column":336,"nodeType":"153","messageId":"154","endLine":7,"endColumn":342},{"ruleId":"151","severity":1,"message":"203","line":7,"column":343,"nodeType":"153","messageId":"154","endLine":7,"endColumn":349},{"ruleId":"151","severity":1,"message":"204","line":7,"column":350,"nodeType":"153","messageId":"154","endLine":7,"endColumn":357},{"ruleId":"205","severity":1,"message":"206","line":7,"column":583,"nodeType":"207","messageId":"208","endLine":7,"endColumn":584},{"ruleId":"186","severity":1,"message":"187","line":8,"column":1,"nodeType":"188","messageId":"189","endLine":8,"endColumn":14,"fix":"209"},{"ruleId":"186","severity":1,"message":"187","line":23,"column":1,"nodeType":"188","messageId":"189","endLine":23,"endColumn":14,"fix":"210"},{"ruleId":"186","severity":1,"message":"187","line":151,"column":1,"nodeType":"188","messageId":"189","endLine":151,"endColumn":14,"fix":"211"},{"ruleId":"212","severity":1,"message":"213","line":179,"column":8,"nodeType":"153","messageId":"214","endLine":179,"endColumn":9},{"ruleId":"212","severity":1,"message":"213","line":179,"column":33,"nodeType":"153","messageId":"214","endLine":179,"endColumn":34},{"ruleId":"212","severity":1,"message":"213","line":180,"column":18,"nodeType":"153","messageId":"214","endLine":180,"endColumn":19},{"ruleId":"212","severity":1,"message":"213","line":180,"column":39,"nodeType":"153","messageId":"214","endLine":180,"endColumn":40},{"ruleId":"212","severity":1,"message":"213","line":181,"column":18,"nodeType":"153","messageId":"214","endLine":181,"endColumn":19},{"ruleId":"212","severity":1,"message":"213","line":181,"column":39,"nodeType":"153","messageId":"214","endLine":181,"endColumn":40},{"ruleId":"186","severity":1,"message":"187","line":646,"column":1,"nodeType":"188","messageId":"189","endLine":646,"endColumn":14,"fix":"215"},{"ruleId":"186","severity":1,"message":"187","line":784,"column":1,"nodeType":"188","messageId":"189","endLine":784,"endColumn":14,"fix":"216"},{"ruleId":"186","severity":1,"message":"187","line":903,"column":1,"nodeType":"188","messageId":"189","endLine":903,"endColumn":14,"fix":"217"},{"ruleId":"186","severity":1,"message":"187","line":1187,"column":1,"nodeType":"188","messageId":"189","endLine":1187,"endColumn":14,"fix":"218"},{"ruleId":"186","severity":1,"message":"187","line":1457,"column":1,"nodeType":"188","messageId":"189","endLine":1457,"endColumn":14,"fix":"219"},{"ruleId":"186","severity":1,"message":"187","line":1557,"column":1,"nodeType":"188","messageId":"189","endLine":1557,"endColumn":14,"fix":"220"},{"ruleId":"221","severity":1,"message":"222","line":1655,"column":16,"nodeType":"153","messageId":"177","endLine":1655,"endColumn":25,"fix":"223"},{"ruleId":"145","replacedBy":"224"},{"ruleId":"147","replacedBy":"225"},"no-native-reassign",["226"],"no-negated-in-lhs",["227"],["226"],["227"],"no-unused-vars","'useWindowSize' is defined but never used.","Identifier","unusedVar","'LPF' is defined but never used.","'ma' is defined but never used.","'dma' is defined but never used.","'sma' is defined but never used.","'wma' is defined but never used.","'image' is defined but never used.","'defaultX1' is assigned a value but never used.","'defaultY1' is assigned a value but never used.","'defaultX2' is assigned a value but never used.","'defaultY2' is assigned a value but never used.","'graphHeight' is assigned a value but never used.","'setGraphHeight' is assigned a value but never used.","'setSmooth' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'drawingCanvasHeight' and 'drawingCanvasWidth'. Either include them or remove the dependency array.","ArrayExpression",["228"],"React Hook useEffect contains a call to 'setX1'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass [plotLine, x1p, frameWidth, bildetHeight, y1p, x2p, y2p] as a second argument to the useEffect Hook.",["229"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-redeclare","'i' is already defined.","redeclared","'redraw' is defined but never used.","'setEndpointStrokeWidth' is assigned a value but never used.","'circleDivStyle' is assigned a value but never used.","'circleStyleDark' is assigned a value but never used.","'useEffect' is defined but never used.","strict","'use strict' is unnecessary inside of modules.","ExpressionStatement","module",{"range":"230","text":"231"},["226"],["227"],{"range":"232","text":"231"},["226"],["227"],"no-undef","'define' is not defined.","undef","no-restricted-globals","Unexpected use of 'self'.","defaultMessage","'define' is defined but never used.","'module' is defined but never used.","'exports' is defined but never used.","no-sequences","Unexpected use of comma operator.","SequenceExpression","unexpectedCommaExpression",{"range":"233","text":"231"},{"range":"234","text":"231"},{"range":"235","text":"231"},"no-use-before-define","'i' was used before it was defined.","usedBeforeDefined",{"range":"236","text":"231"},{"range":"237","text":"231"},{"range":"238","text":"231"},{"range":"239","text":"231"},{"range":"240","text":"231"},{"range":"241","text":"231"},"no-extra-label","This label '_function' is unnecessary.",{"range":"242","text":"231"},["226"],["227"],"no-global-assign","no-unsafe-negation",{"desc":"243","fix":"244"},{"desc":"245","fix":"246"},[63,76],"",[1026,1039],[953,966],[1455,1468],[9733,9746],[23558,23571],[27096,27109],[30011,30024],[38978,38991],[45558,45571],[48148,48161],[50440,50450],"Update the dependencies array to be: [drawingCanvasHeight, drawingCanvasWidth]",{"range":"247","text":"248"},"Add dependencies array: [plotLine, x1p, frameWidth, bildetHeight, y1p, x2p, y2p]",{"range":"249","text":"250"},[2810,2812],"[drawingCanvasHeight, drawingCanvasWidth]",[3287,3287],", [plotLine, x1p, frameWidth, bildetHeight, y1p, x2p, y2p]"]