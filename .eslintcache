[{"C:\\Users\\Thomas\\grain\\src\\index.js":"1","C:\\Users\\Thomas\\grain\\src\\App.js":"2","C:\\Users\\Thomas\\grain\\src\\reportWebVitals.js":"3","C:\\Users\\Thomas\\grain\\src\\Frame.js":"4","C:\\Users\\Thomas\\grain\\src\\registerServiceWorker.js":"5","C:\\Users\\Thomas\\grain\\src\\Indicator.js":"6","C:\\Users\\Thomas\\grain\\src\\Graph.js":"7","C:\\Users\\Thomas\\grain\\src\\Bildet.js":"8","C:\\Users\\Thomas\\grain\\src\\canvas-bezier-multipoint.js":"9","C:\\Users\\Thomas\\grain\\src\\curve.js":"10","C:\\Users\\Thomas\\grain\\src\\LPF.js":"11","C:\\Users\\Thomas\\grain\\src\\Measurer.js":"12","C:\\Users\\Thomas\\grain\\src\\useDrag.js":"13","C:\\Users\\Thomas\\grain\\src\\useDrag2.js":"14","C:\\Users\\Thomas\\grain\\src\\fili.js":"15","C:\\Users\\Thomas\\grain\\src\\Animator.js":"16","C:\\Users\\Thomas\\grain\\src\\useWindowSize.js":"17"},{"size":254,"mtime":1499981087783,"results":"18","hashOfConfig":"19"},{"size":396,"mtime":1616517577907,"results":"20","hashOfConfig":"19"},{"size":362,"mtime":499162500000,"results":"21","hashOfConfig":"22"},{"size":14300,"mtime":1623085998644,"results":"23","hashOfConfig":"19"},{"size":4022,"mtime":1499981087000,"results":"24","hashOfConfig":"19"},{"size":3631,"mtime":1622415036092,"results":"25","hashOfConfig":"19"},{"size":637,"mtime":1617872364577,"results":"26","hashOfConfig":"19"},{"size":2383,"mtime":1617828982240,"results":"27","hashOfConfig":"19"},{"size":3605,"mtime":1614717092214,"results":"28","hashOfConfig":"22"},{"size":3440,"mtime":1614719265093,"results":"29","hashOfConfig":"19"},{"size":2176,"mtime":1614722929993,"results":"30","hashOfConfig":"19"},{"size":248,"mtime":1614883848575,"results":"31","hashOfConfig":"22"},{"size":1439,"mtime":1614949481477,"results":"32","hashOfConfig":"22"},{"size":1419,"mtime":1614948903133,"results":"33","hashOfConfig":"22"},{"size":52704,"mtime":1616504287885,"results":"34","hashOfConfig":"22"},{"size":793,"mtime":1617199112712,"results":"35","hashOfConfig":"19"},{"size":1149,"mtime":1617203772482,"results":"36","hashOfConfig":"19"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},"1x1fz4d",{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},"dxlfja",{"filePath":"45","messages":"46","errorCount":0,"warningCount":20,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"39"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55","usedDeprecatedRules":"39"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":"60","usedDeprecatedRules":"61"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"64","usedDeprecatedRules":"39"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"69","usedDeprecatedRules":"70"},{"filePath":"71","messages":"72","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"70"},{"filePath":"73","messages":"74","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"70"},{"filePath":"75","messages":"76","errorCount":4,"warningCount":20,"fixableErrorCount":0,"fixableWarningCount":10,"source":"77","usedDeprecatedRules":"78"},{"filePath":"79","messages":"80","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"81","messages":"82","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},"C:\\Users\\Thomas\\grain\\src\\index.js",[],["83","84"],"C:\\Users\\Thomas\\grain\\src\\App.js",[],"C:\\Users\\Thomas\\grain\\src\\reportWebVitals.js",[],["85","86"],"C:\\Users\\Thomas\\grain\\src\\Frame.js",["87","88","89","90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105","106"],"/*\nthis, Frame.js, is the container\n  for the image object and indicator objects and graph object and settings\nits purpose is\n  to be a centered, dynamically resizing container in which to place its children\nit is vertically centered and full screen width up to 70 em\n\nNOW:\n  title should center vertically in available space, also on resize\n\ntodo today\n  play button should not go out of right bounds\n  subtitles should fit narrow width/height\n  play line should be same style as scan line\n  play line should be accurately placed\n  graph should have a solid relation to its borders\n\nTODO BUGS:\n  check performance on low end devices\n  when dragging outside canvas, crash: set dragging bounds\n  sometimes a line of background is visible, depending on width of window\n  when resizing small horizontally, top disappears\n  title is jumping with bars\n  when dragging circle, it cuts edge (make margin bigger?)\n\nTODO ADJUST:\n  dynamic contrast of circles\n  limit to 100 points for animation export\n  currently only red is used?\n  white screen before load rather than flashing random stuff\n\nTODO CLEANUP:\n  use return rather than method props ... in order to encapsulate\n  clean up code so far\n  clean up warnings in console\n  combine useeffect in one, not two?\n  consider baking usestates inside one object\n  make sure that all references to size is pointing to a var\n  check all prop sends are good style\n\nTODO FEATURES:\n  circles are hand drawn on transparent\n  get it on git\n  make lowpass filter damping dynamic by fader\n  l and r markers of handles are missing\n  settings menu is missing, with smooth\n  handle should transform on hover\n  framing of graph is missing\n\nTODO DOCUMENT:\n  credit: drag and drop library\n  credit: LPF library: https://www.npmjs.com/package/lpf\n  credit: curve library\n  credit new draggable from https://levelup.gitconnected.com/create-an-easy-custom-react-hook-for-dragging-components-3779b30d08b5\n  credit translate values from https://sagarpansuriya.wordpress.com/2020/08/08/how-to-get-css-translate-values-with-javascript/\n  moving average: https://github.com/kaelzhang/moving-averages#readme\n  useWindowSize: https://usehooks.com/useWindowSize/\n\nDONE: \n  filter starts at strange position - must pad start values?\n  position handles and line mid-canvas at start\n  svg container for line is not in place\n  bug: line is not always centering within circle: x and y on mark\n  main issue: image canvas is too big, skewing scan coordinates\n  filter is strange behavior - suspect filter or curve does not like minus values - convert all to +?\n  handles are off screen: check position:relative, etc.\n  line is not centering in handles: follow and ... reqth\n  graph is not scaling correctly: drawingcanvaswidth should be replaced with winwos wideth\n  how to get portion of image that i want\n  filter has strange shark fin curve on hard onsets - get better filter? yes, get or make second order filter\n  when handle/line position is not scaling: x1 should be dynamic width of canvas + something \n  graph is too high: on resize get height of graph, etc.\n*/\n\nimport React, {useState, useEffect, useRef} from 'react';\nimport './Frame.css';\nimport Bildet from './Bildet'; // import image object to display\nimport Graph from './Graph';\nimport Animator from './Animator';\nimport useWindowSize from './useWindowSize';\nimport './curve.js';\nimport LPF from './LPF.js';\nimport {ma, dma, ema, sma, wma} from 'moving-averages'\nimport image from \"./images/stones.jpg\"\n\nfunction Frame() {\n\n  const [frameWidth, setFrameWidth] = useState(100);\n  const [bildetHeight, setBildetHeight] = useState(100);\n\n  // references for canvas before it is initialized\n  const imageCanvasRef = useRef(null);\n  const drawingCanvasRef = useRef(null);\n\n  // state variables\n  const [x1, setX1] = useState(100);    // indicator endpoint 1 x coordinate\n  const [y1, setY1] = useState(100);    //   and y coordinate\n  const [x2, setX2] = useState(300);    // indicator endpoint 2 x coordinate\n  const [y2, setY2] = useState(200);    //   and y coordinate\n\n  const [x1p, setX1p] = useState(0.2);    // indicator endpoint 1 x coordinate\n  const [y1p, setY1p] = useState(0.2);    //   and y coordinate\n  const [x2p, setX2p] = useState(0.3);    // indicator endpoint 2 x coordinate\n  const [y2p, setY2p] = useState(0.3);    //   and y coordinate\n\n  const defaultX1 = 100;\n  const defaultY1 = 270;\n  const defaultX2 = 100;\n  const defaultY2 = 200;\n\n  const [drawingCanvasWidth, setDrawingCanvasWidth] = useState(null);\n  const [drawingCanvasHeight, setDrawingCanvasHeight] = useState(null);\n  const [graphHeight, setGraphHeight] = useState(null);\n\n  const [smooth, setSmooth] = useState(3);    // indicator endpoint 1 x coordinate\n\n  // dynamic number of points based on length of line, or static 100 points?\n  const numberOfPoints = 100;\n  const [calibratePoint, setCalibratePoint] = useState(0);\n\n  // initialize array for points of color along line\n  var points = [];\n\n  // on first render\n  useEffect(() => {\n\n    console.log('bare første gang');\n\n    // get width, height from frame, set canvas dimensions\n    setDrawingCanvasWidth(document.getElementById('drawingCanvas').getBoundingClientRect().width);\n    setDrawingCanvasHeight(document.getElementById('drawingCanvas').getBoundingClientRect().height);\n    initCanvas(drawingCanvasWidth, drawingCanvasHeight);\n\n    // add event listener for resizing\n    window.addEventListener(\"resize\", handleResize);\n\n    // call handler right away so state gets updated with initial window size\n    handleResize();\n  }, []);\n\n  // on every change in state\n  useEffect(() => {\n    console.log('hver gang noe endres i frame'); // som når resize trigger [set]\n\n    plotLine();\n\n    // this is what scales handles and line !!\n    setX1(x1p * frameWidth);\n    setY1(bildetHeight * y1p);\n    console.log('x1p ' + x1p);\n\n    setX2(frameWidth * x2p);\n    setY2(bildetHeight * y2p);\n\n    /*\n    setX1(frameWidth/5);\n    setX2(frameWidth/2);\n    setY1(bildetHeight/10);\n    setY2(bildetHeight/5);\n    */\n  });\n\n  // initialize canvases\n  function initCanvas (initx, inity) {\n\n    const imageCtx = imageCanvasRef.current.getContext(\"2d\");\n    const drawCtx = drawingCanvasRef.current.getContext(\"2d\");\n\n    imageCtx.fillStyle = \"#FAFAFA\";\n\n    // make background fill - is this necessary?\n    drawCtx.fillStyle = \"#FAF2F2\";\n    drawCtx.fillRect(0, 0, initx, inity);\n\n    drawCtx.strokeStyle = \"#AA9999\";\n    drawCtx.lineWidth = 2;\n  }\n\n  // record handle positions for use by line drawing and line scanning\n  function setXY(handleID, xgot, ygot) {\n    if (handleID == 0) {\n      console.log('nå flytter vi');\n\n      setX1p(xgot / frameWidth);\n      console.log('xgot ' + xgot + ' frameWidth ' + frameWidth + ' x1p ' + x1p);\n      setX1(frameWidth * x1p);\n      setY1p(ygot / bildetHeight);\n      setY1(frameWidth * y1p);\n    }\n    if (handleID == 1) {\n      setX2p(xgot / frameWidth);\n      setX2(frameWidth * x2p);\n      setY2p(ygot / bildetHeight);\n      setY2(frameWidth * y2p);\n    }\n  }\n\n  function handleResize() {\n    // Set window width/height to state\n    setFrameWidth(document.getElementById('frame').getBoundingClientRect().width);\n    setBildetHeight(document.getElementById('bildet').getBoundingClientRect().height);\n\n    console.log('resized');\n  }\n\n  // function for drawing graph from line, walk through coordinates of line, for each point extract colo value and plot on graph\n  function plotLine () {\n\n    // is there a more ... way of doing this check for exist, etc.?\n    const imageCtx = imageCanvasRef.current.getContext(\"2d\");\n    const drawCtx = drawingCanvasRef.current.getContext(\"2d\");\n\n    drawCtx.clearRect(0, 0, drawingCanvasWidth, drawingCanvasHeight);\n    drawCtx.strokeStyle = \"#AA9999\";\n    drawCtx.lineWidth = 1.0;\n    drawCtx.lineCap = 'round';\n    drawCtx.beginPath();\n\n    // special coordinates for extracting data\n    // here we are scaling x and y to account for mismatch due to static width image source vs potentially resized canvas\n    const lx1 = x1 * (1120 / frameWidth);\n    const ly1 = y1 * (1120 / frameWidth);\n    const lx2 = x2 * (1120 / frameWidth);\n    const ly2 = y2 * (1120 / frameWidth);\n\n    var firstColorPoint = 255 - imageCtx.getImageData(lx1, ly1, 1, 1).data[0];\n    var lastColorPoint = 255 - imageCtx.getImageData(lx2, ly2, 1, 1).data[0];\n\n    console.log('first color point ' + firstColorPoint);\n\n    // populate points array with color values along line\n    for (var i=0; i<numberOfPoints; i++) {\n\n      // get color data from pixel at current point along line\n      var data = imageCtx.getImageData(lx1 + ((lx2 - lx1) / numberOfPoints * i), ly1 + ((ly2 - ly1) / numberOfPoints * i), 1, 1).data;\n\n      // append new value to the array\n      points.push(255 - data[1]);\n    }\n\n    // filter points\n    points = filter(points, firstColorPoint, lastColorPoint);\n\n    for (var i=1; i<numberOfPoints; i++) {\n      drawCtx.lineTo(drawingCanvasWidth/numberOfPoints*i, points[i] / 255 * drawingCanvasHeight);\n    }\n    \n    drawCtx.stroke();\n\n    setCalibratePoint(points[0]);\n    document.getElementById(\"playTriangle\").style.transform = \"translate(\" + (480 - (points[0] + calibratePoint)) + \"px)\";\n  }\n\n  // filtering points to be graphed, using LPF library\n  function filter (points, firstColorPoint, lastColorPoint) {\n\n    // duplicate backwards 30 times for lowpass to be able to smooth backwards\n    for (var i=0; i < 30; i++) {\n      points.unshift(firstColorPoint);\n    }\n\n    // duplicate forwards 30 times for lowpass to be able to smooth forwards\n    for (var i=0; i < 30; i++) {\n      points.push(lastColorPoint);\n    }\n\n    //points = sma(points, 2, 1.7);\n    //points = sma(points, 10, 2.1);\n    //points = sma(points, 10, 2.1);\n    //points = sma(points, 10, 2.1);\n    //points = sma(points, 10, 2.1);\n    //points = sma(points, 10, 2.1);\n    \n    points = ema(points, smooth);\n    points = ema(points, smooth);\n    points = ema(points, smooth);\n    points = ema(points, smooth);\n    points = ema(points, smooth);\n\n    //console.log('smo ' + smooth);\n\n    // remove 30 pre points again\n    points.splice(0, 30);\n\n    return points\n  }\n\n  function redraw() {\n\n    /*\n    var canvasPic = document.getElementById(\"canvasPic\");\n    var ctx = canvasPic.getContext(\"2d\");\n\n    ctx.clearRect(0, 0, 12, 40);\n    ctx.fillStyle = \"#00FFF2\";         // make background fill (is this necessary?)\n    ctx.fillRect(0, 0, 112, 36);\n\n    var imageObj = new Image();\n    imageObj.src = image;\n    imageObj.onload = function() {\n      //void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n\n      ctx.drawImage(imageObj, 0, 0, frameWidth, 100);\n    };\n    */\n\n    console.log('redraw ');\n  }\n\n  function startTransition () {\n\n    var myVar = setInterval(myTimer, 15);\n\n    var direction = 1;\n    var i = 0;\n\n    function myTimer() {\n\n      //document.getElementById('playTriangle').style.top = (480 - (points[i] + calibratePoint));\n      //document.getElementById('playTriangle').style.marginLeft = (480 - (points[i] + calibratePoint));\n      //document.getElementById('playTriangle').style.opacity = (1 - (0 - ((points[i] - calibratePoint) / calibratePoint)));\n      //document.getElementById('playTriangle').style.transform = \"translate \" + (480 - (points[i] + calibratePoint)) + \"px\";\n      //document.getElementById('playTriangle').style.transform = {translate,};\n      //document.getElementById(\"playTriangle\").style.transform = \"translate(200px)\";\n      //document.getElementById(\"myDIV\").style.transform = \"translate(20%,100%)\";\n      document.getElementById(\"playTriangle\").style.transform = \"translate(\" + (480 - (points[i] + calibratePoint)) + \"px)\";\n\n      if(direction === 1){\n        i++;\n      }\n\n      if(direction === 0){\n        i--;\n      }\n\n      if(i === numberOfPoints){\n        direction = 0;\n      }\n\n      // draw index line\n      document.getElementById(\"playIndexLine\").style.transform = \"translate(\" + (((drawingCanvasWidth - 25)/numberOfPoints) * i) + \"px)\";\n\n\n      if(i === -1){\n        direction = 1;\n        clearInterval(myVar);\n      }\n    }\n  }\n\n  return (\n    <div id=\"frame\">\n\n      <p onClick={redraw} id='titlen'>CSS transition from image</p>\n\n      <Bildet\n        plotLine={plotLine}\n        passRef={imageCanvasRef}\n        x1={x1} y1={y1} x2={x2} y2={y2}\n        xyChange={setXY}\n        frameWidth={frameWidth}\n        bildetHeight={bildetHeight}/>    \n      <Graph\n        passRef={drawingCanvasRef}\n        drawingCanvasWidth={drawingCanvasWidth}\n        drawingCanvasHeight={drawingCanvasHeight} />\n      <Animator \n        startTransition={startTransition}/>\n    </div>\n  );\n}\n\nexport default Frame;\n\n\n\n\n\n\n/* \n    cutouts:\n\n    // set low pass factor\n    LPF.smoothing = 0.5;\n\n    // do the filtering\n    LPF.smoothArray(points)\n\n    // for fill\n    drawCtx.lineTo(drawingCanvasWidth, drawingCanvasHeight/2);      \n    drawCtx.lineTo(drawingCanvasWidth, drawingCanvasHeight);      \n    drawCtx.fillStyle = \"#EEDDDD\";\n    drawCtx.fill();\n    \n    // for smooting (but do i need smooting when i have low pass?\n    drawCtx.curve(points2, 0.2);\n\n\n\n\n * Gets computed translate values\n * @param {HTMLElement} element\n * @returns {Object}\n \n\nfunction getTranslateValues (element) {\n  const style = window.getComputedStyle(element)\n  const matrix = style.transform || style.webkitTransform || style.mozTransform\n\n  // No transform property. Simply return 0 values.\n  if (matrix === 'none') {\n    return {\n      x: 0,\n      y: 0,\n      z: 0\n    }\n  }\n\n  // Can either be 2d or 3d transform\n  const matrixType = matrix.includes('3d') ? '3d' : '2d'\n  const matrixValues = matrix.match(/matrix.*\\((.+)\\)/)[1].split(', ')\n\n  // 2d matrices have 6 values\n  // Last 2 values are X and Y.\n  // 2d matrices does not have Z value.\n  if (matrixType === '2d') {\n    return {\n      x: matrixValues[4],\n      y: matrixValues[5],\n      z: 0\n    }\n  }\n\n  // 3d matrices have 16 values\n  // The 13th, 14th, and 15th values are X, Y, and Z\n  if (matrixType === '3d') {\n    return {\n      x: matrixValues[12],\n      y: matrixValues[13],\n      z: matrixValues[14]\n    }\n  }\n}\n\n\n    // console.log('x === ' + e.screenX);\n    setSmooth(((e.screenX) / 50) - 7.3 );\n    console.log('smooth ' + smooth);\n    if (smooth <= 1.1) {\n      setSmooth(1.11);\n    }\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","C:\\Users\\Thomas\\grain\\src\\registerServiceWorker.js",[],"C:\\Users\\Thomas\\grain\\src\\Indicator.js",["107","108","109"],"// indicator component:\r\n//\t a line draggable by its endpoints,\r\n//   indicating what pixels from underlying image to process.\r\n//   for use in frame component\r\n\r\nimport React, { useState, useEffect } from 'react';\r\nimport Draggable from 'react-draggable';  // import react-draggable, which is installed via npm, for dragging elements\r\nimport './Indicator.css';\r\n \r\nfunction Indicator (props) {\r\n\r\n  const [endpointStrokeWidth, setEndpointStrokeWidth] = useState('0.42em');\r\n\r\n  // dynamic styles\r\n  const indicatorDivStyle = {\r\n    position: 'relative',\r\n    //backgroundColor: 'red',\r\n\r\n    width: '100%',\r\n    height: '100%',\r\n    //top: '50%',\r\n    //left: '50%',\r\n    //transform: 'translate(-50%, -50%)',\r\n  };\r\n\r\n  const lineStyle = {\r\n    position: 'absolute',\r\n    stroke: '#6b6b6b',\r\n    strokeWidth: '0.2em',\r\n    opacity: '0.7',\r\n  };\r\n\r\n  const circleDivStyle = {\r\n    display: 'inline-block',\r\n    height: '30px',\r\n    width: '30px',\r\n    zIndex: 2\r\n  };\r\n\r\n  const circleStyleDark = {\r\n    stroke: '#554444',\r\n    opacity: '0.3',\r\n    fill: 'none',\r\n    strokeWidth: endpointStrokeWidth\r\n  };\r\n\r\n  const circleStyle = {\r\n    stroke: '#554444',\r\n    opacity: '0.3',\r\n    fill: 'none',\r\n    strokeWidth: endpointStrokeWidth\r\n  };\r\n\r\n  const svgteststyle = {\r\n    transform: 'translate(-2.5em, -2.5em)',\r\n    top: '30px',\r\n    //backgroundColor: 'red',\r\n    preserveAspectRatio: \"none\",\r\n  }\r\n\r\n  const svgLineStyle = {\r\n    position: 'absolute'\r\n  }\r\n\r\n  // on every change in state\r\n  useEffect(() => {\r\n      console.log('useeffect indicator with x, y ' + props.x1 + ', ' + props.y1);\r\n\r\n  });\r\n\r\n  function handleMove5 (e, ui) {\r\n    props.xyChange(0, ui.x, ui.y);\r\n    // console.log('handle1 ui x ' + ui.x + ' ui y ' + ui.y);\r\n  }\r\n\r\n  function handleMove6 (e, ui) {\r\n    props.xyChange(1, ui.x, ui.y);\r\n    // console.log('handle2 ui x ' + ui.x + ' ui y ' + ui.y);\r\n  }\r\n\r\n  return (\r\n    \r\n    // indicator container div\r\n    // line is 0 + because otherwise it assumes some default strange pos\r\n    // +0 because style transform needs an int in  order to work\r\n    <div id=\"indicator\" style={indicatorDivStyle}>\r\n      \r\n      {/*line*/}\r\n      <svg style={svgLineStyle} width=\"100%\" height=\"100%\" >\r\n        <line id='line'\r\n              style={lineStyle}\r\n              x1={props.x1 + 0}\r\n              y1={props.y1 + 0}\r\n              x2={props.x2 + 0}\r\n              y2={props.y2 + 0} />\r\n      </svg>\r\n\r\n      {/*handle l*/}\r\n      <Draggable\r\n        id='draggable1'\r\n        axis=\"both\"\r\n        handle=\".handle\"\r\n        position={{x: props.x1, y: props.y1}}\r\n        scale={1}\r\n        onDrag={handleMove5}\r\n        // onStop={handleStop5p}\r\n        >  \r\n        \r\n        <div id='handle1'>\r\n    \r\n          <svg style={svgteststyle}    \r\n            className=\"handle\"\r\n            width='5em'\r\n            height=\"5em\"\r\n            viewBox=\"56 56 112 112\">\r\n\r\n            <circle style={circleStyle} cx={'112'} cy={'112'} r={'25'}/>\r\n          </svg>\r\n        </div>\r\n      </Draggable>\r\n\r\n      {/*handle r*/}\r\n      <Draggable\r\n        id='draggable2'\r\n        axis=\"both\"\r\n        handle=\".handle\"\r\n        position={{x: props.x2, y: props.y2}}\r\n        scale={1}\r\n        onDrag={handleMove6}\r\n        >  \r\n        \r\n        <div id='handle2'>\r\n      \r\n          <svg style={svgteststyle}    \r\n            className=\"handle\"\r\n            width='5em'\r\n            height=\"5em\"\r\n            viewBox=\"0 0 112 112\">\r\n\r\n            <circle style={circleStyle} cx={'56'} cy={'56'} r={'25'}/>\r\n          </svg>\r\n        </div>\r\n      </Draggable>\r\n\r\n\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Indicator;","C:\\Users\\Thomas\\grain\\src\\Graph.js",["110"],"//image from which to extract data, based on position of indicator line overlay\r\n\r\nimport React, { useEffect } from 'react';\r\nimport './Graph.css';\r\n\r\nfunction Graph (props) {\r\n  return (\r\n    <div className='graph'> {/*comment here*/}\r\n      <canvas ref={props.passRef} id=\"drawingCanvas\" width={props.drawingCanvasWidth} height={props.drawingCanvasHeight}></canvas>\r\n      <svg id='playIndexLine' width=\"10%\" height=\"100%\" >\r\n        <line id='line' x1='22' y1='0' x2='22' y2='200' />\r\n      </svg>\r\n      <p id='graphTitle'>graph represents image brightness along line between circles</p>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Graph;","C:\\Users\\Thomas\\grain\\src\\Bildet.js",[],"C:\\Users\\Thomas\\grain\\src\\canvas-bezier-multipoint.js",["111","112"],"export function bezierCurveThrough(ctx, points, tension) {\n    'use strict';\n\n    // Default tension of one-quarter gives nice results\n    tension = tension || 0.25;\n\n    var l = points.length;\n\n    // If we're given less than two points, there's nothing we can do\n    if (l < 2) return;\n\n    ctx.beginPath();\n\n    // If we only have two points, we can only draw a straight line\n    if (l == 2) {\n        ctx.moveTo(points[0][0], points[0][1]);\n        ctx.lineTo(points[1][0], points[1][1]);\n        ctx.stroke();\n        return;\n    }\n\n    // Helper function to calculate the hypotenuse\n    function h(x, y) {\n        return Math.sqrt(x * x + y * y);\n    }\n\n    /* For each interior point, we need to calculate the tangent and pick\n     * two points on it that'll serve as control points for curves to and\n     * from the point. */\n    var cpoints = [];\n    points.forEach(function() {\n        cpoints.push({});\n    });\n\n    for (var i = 1; i < l - 1; i++) {\n        var pi = points[i],     // current point\n            pp = points[i - 1], // previous point\n            pn = points[i + 1]; // next point;\n\n        /* First, we calculate the normalized tangent slope vector (dx,dy).\n         * We intentionally don't work with the derivative so we don't have\n         * to handle the vertical line edge cases separately. */\n\n        var rdx = pn[0] - pp[0],  // actual delta-x between previous and next points\n            rdy = pn[1] - pp[1],  // actual delta-y between previous and next points\n            rd = h(rdx, rdy),     // actual distance between previous and next points\n            dx = rdx / rd,        // normalized delta-x (so the total distance is 1)\n            dy = rdy / rd;        // normalized delta-y (so the total distance is 1)\n\n        /* Next we calculate distances to previous and next points, so we\n         * know how far out to put the control points on the tangents (tension).\n         */\n\n        var dp = h(pi[0] - pp[0], pi[1] - pp[1]), // distance to previous point\n            dn = h(pi[0] - pn[0], pi[1] - pn[1]); // distance to next point\n\n        /* Now we can calculate control points. Previous control point is\n         * located on the tangent of the curve, with the distance between it\n         * and the current point being a fraction of the distance between the\n         * current point and the previous point. Analogous to next point. */\n\n        var cpx = pi[0] - dx * dp * tension,\n            cpy = pi[1] - dy * dp * tension,\n            cnx = pi[0] + dx * dn * tension,\n            cny = pi[1] + dy * dn * tension;\n\n        cpoints[i] = {\n            cp: [cpx, cpy], // previous control point\n            cn: [cnx, cny], // next control point\n       };\n    }\n\n    /* For the end points, we only need to calculate one control point.\n     * Picking a point in the middle between the endpoint and the other's\n     * control point seems to work well. */\n\n    cpoints[0] = {\n        cn: [ (points[0][0] + cpoints[1].cp[0]) / 2, (points[0][1] + cpoints[1].cp[1]) / 2 ],\n    };\n    cpoints[l - 1] = {\n        cp: [ (points[l - 1][0] + cpoints[l - 2].cn[0]) / 2, (points[l - 1][1] + cpoints[l - 2].cn[1]) / 2 ],\n    };\n\n    /* Now we can draw! */\n\n    ctx.moveTo(points[0][0], points[0][1]);\n\n    for (i = 1; i < l; i++) {\n        var p = points[i],\n            cp = cpoints[i],\n            cpp = cpoints[i - 1];\n\n        /* Each bezier curve uses the \"next control point\" of first point\n         * point, and \"previous control point\" of second point. */\n        ctx.bezierCurveTo(cpp.cn[0], cpp.cn[1], cp.cp[0], cp.cp[1], p[0], p[1]);\n    }\n\n    ctx.stroke();\n}\n",["113","114"],"C:\\Users\\Thomas\\grain\\src\\curve.js",["115"],"/*!\tCurve extension for canvas 2.3.1\r\n *\tEpistemex (c) 2013-2014\r\n *\tLicense: MIT\r\n */\r\n\r\n/**\r\n * Draws a cardinal spline through given point array. Points must be arranged\r\n * as: [x1, y1, x2, y2, ..., xn, yn]. It adds the points to the current path.\r\n *\r\n * The method continues previous path of the context. If you don't want that\r\n * then you need to use moveTo() with the first point from the input array.\r\n *\r\n * The points for the cardinal spline are returned as a new array.\r\n *\r\n * @param {Array} points - point array\r\n * @param {Number} [tension=0.5] - tension. Typically between [0.0, 1.0] but can be exceeded\r\n * @param {Number} [numOfSeg=20] - number of segments between two points (line resolution)\r\n * @param {Boolean} [close=false] - Close the ends making the line continuous\r\n * @returns {Float32Array} New array with the calculated points that was added to the path\r\n */\r\nCanvasRenderingContext2D.prototype.curve = CanvasRenderingContext2D.prototype.curve || function(points, tension, numOfSeg, close) {\r\n\r\n\t'use strict';\r\n\r\n\t// options or defaults\r\n\ttension = (typeof tension === 'number') ? tension : 0.5;\r\n\tnumOfSeg = numOfSeg ? numOfSeg : 25;\r\n\r\n\tvar pts,\t\t\t\t\t\t\t\t\t// for cloning point array\r\n\t\ti = 1,\r\n\t\tl = points.length,\r\n\t\trPos = 0,\r\n\t\trLen = (l-2) * numOfSeg + 2 + (close ? 2 * numOfSeg: 0),\r\n\t\tres = new Float32Array(rLen),\r\n\t\tcache = new Float32Array((numOfSeg + 2) * 4),\r\n\t\tcachePtr = 4;\r\n\r\n\tpts = points.slice(0);\r\n\r\n\tif (close) {\r\n\t\tpts.unshift(points[l - 1]);\t\t\t\t// insert end point as first point\r\n\t\tpts.unshift(points[l - 2]);\r\n\t\tpts.push(points[0], points[1]); \t\t// first point as last point\r\n\t}\r\n\telse {\r\n\t\tpts.unshift(points[1]);\t\t\t\t\t// copy 1. point and insert at beginning\r\n\t\tpts.unshift(points[0]);\r\n\t\tpts.push(points[l - 2], points[l - 1]);\t// duplicate end-points\r\n\t}\r\n\r\n\t// cache inner-loop calculations as they are based on t alone\r\n\tcache[0] = 1;\t\t\t\t\t\t\t\t// 1,0,0,0\r\n\r\n\tfor (; i < numOfSeg; i++) {\r\n\r\n\t\tvar st = i / numOfSeg,\r\n\t\t\tst2 = st * st,\r\n\t\t\tst3 = st2 * st,\r\n\t\t\tst23 = st3 * 2,\r\n\t\t\tst32 = st2 * 3;\r\n\r\n\t\tcache[cachePtr++] =\tst23 - st32 + 1;\t// c1\r\n\t\tcache[cachePtr++] =\tst32 - st23;\t\t// c2\r\n\t\tcache[cachePtr++] =\tst3 - 2 * st2 + st;\t// c3\r\n\t\tcache[cachePtr++] =\tst3 - st2;\t\t\t// c4\r\n\t}\r\n\r\n\tcache[++cachePtr] = 1;\t\t\t\t\t\t// 0,1,0,0\r\n\r\n\t// calc. points\r\n\tparse(pts, cache, l);\r\n\r\n\tif (close) {\r\n\t\t//l = points.length;\r\n\t\tpts = [];\r\n\t\tpts.push(points[l - 4], points[l - 3], points[l - 2], points[l - 1]); // second last and last\r\n\t\tpts.push(points[0], points[1], points[2], points[3]); // first and second\r\n\t\tparse(pts, cache, 4);\r\n\t}\r\n\r\n\tfunction parse(pts, cache, l) {\r\n\r\n\t\tfor (var i = 2, t; i < l; i += 2) {\r\n\r\n\t\t\tvar pt1 = pts[i],\r\n\t\t\t\tpt2 = pts[i+1],\r\n\t\t\t\tpt3 = pts[i+2],\r\n\t\t\t\tpt4 = pts[i+3],\r\n\r\n\t\t\t\tt1x = (pt3 - pts[i-2]) * tension,\r\n\t\t\t\tt1y = (pt4 - pts[i-1]) * tension,\r\n\t\t\t\tt2x = (pts[i+4] - pt1) * tension,\r\n\t\t\t\tt2y = (pts[i+5] - pt2) * tension;\r\n\r\n\t\t\tfor (t = 0; t < numOfSeg; t++) {\r\n\r\n\t\t\t\tvar c = t << 2, //t * 4;\r\n\r\n\t\t\t\t\tc1 = cache[c],\r\n\t\t\t\t\tc2 = cache[c+1],\r\n\t\t\t\t\tc3 = cache[c+2],\r\n\t\t\t\t\tc4 = cache[c+3];\r\n\r\n\t\t\t\tres[rPos++] = c1 * pt1 + c2 * pt3 + c3 * t1x + c4 * t2x;\r\n\t\t\t\tres[rPos++] = c1 * pt2 + c2 * pt4 + c3 * t1y + c4 * t2y;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// add last point\r\n\tl = close ? 0 : points.length - 2;\r\n\tres[rPos++] = points[l];\r\n\tres[rPos] = points[l+1];\r\n\r\n\t// add lines to path\r\n\tfor(i = 0, l = res.length; i < l; i += 2)\r\n\t\tthis.lineTo(res[i], res[i+1]);\r\n\r\n\treturn res;\r\n};","C:\\Users\\Thomas\\grain\\src\\LPF.js",[],"C:\\Users\\Thomas\\grain\\src\\Measurer.js",["116"],"\r\nimport './Measurer.css';\r\nimport React, { useEffect } from 'react';\r\n\r\nfunction Measurer (props) {\r\n\r\n    return (\r\n        <div id={props.id}>\r\n          <p>bildet: {props.x1}, {props.y1}</p>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Measurer;",["117","118"],"C:\\Users\\Thomas\\grain\\src\\useDrag.js",[],"C:\\Users\\Thomas\\grain\\src\\useDrag2.js",[],"C:\\Users\\Thomas\\grain\\src\\fili.js",["119","120","121","122","123","124","125","126","127","128","129","130","131","132","133","134","135","136","137","138","139","140","141","142"],"/**\n * @name    fili\n * @version 2.0.3 | December 13th 2018\n * @author  Florian Markert\n * @license MIT\n */\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Fili = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n\n  CalcCascades: require('./src/calcCascades'),\n  Fft: require('./src/fft'),\n  FirCoeffs: require('./src/firCoeffs'),\n  FirFilter: require('./src/firFilter'),\n  IirCoeffs: require('./src/iirCoeffs'),\n  IirFilter: require('./src/iirFilter'),\n  TestFilter: require('./src/testFilter')\n\n};\n\n},{\"./src/calcCascades\":2,\"./src/fft\":3,\"./src/firCoeffs\":4,\"./src/firFilter\":5,\"./src/iirCoeffs\":6,\"./src/iirFilter\":7,\"./src/testFilter\":8}],2:[function(require,module,exports){\n'use strict';\n\nvar IirCoeffs = require('./iirCoeffs');\n\nvar getCoeffs = new IirCoeffs();\n\nvar table = {\n  // values from https://gist.github.com/endolith/4982787#file-all-values-txt\n  bessel: {\n    q: [[0.57735026919], [0.805538281842, 0.521934581669], [1.02331395383, 0.611194546878, 0.510317824749], [1.22566942541, 0.710852074442, 0.559609164796, 0.505991069397], [1.41530886916, 0.809790964842, 0.620470155556, 0.537552151325, 0.503912727276], [1.59465693507, 0.905947107025, 0.684008068137, 0.579367238641, 0.525936202016, 0.502755558204], [1.76552743493, 0.998998442993, 0.747625068271, 0.624777082395, 0.556680772868, 0.519027293158, 0.502045428643], [1.9292718407, 1.08906376917, 0.810410302962, 0.671382379377, 0.591144659703, 0.542678365981, 0.514570953471, 0.501578400482], [2.08691792612, 1.17637337045, 0.872034231424, 0.718163551101, 0.627261751983, 0.569890924765, 0.533371782078, 0.511523796759, 0.50125489338], [2.23926560629, 1.26117120993, 0.932397288146, 0.764647810579, 0.664052481472, 0.598921924986, 0.555480327396, 0.526848630061, 0.509345928377, 0.501021580965], [2.38695091667, 1.34368488961, 0.991497755204, 0.81060830488, 0.701011199665, 0.628878390935, 0.57943181849, 0.545207253735, 0.52208637596, 0.507736060535, 0.500847111042], [2.53048919562, 1.42411783481, 1.04937620183, 0.85593899901, 0.737862159044, 0.659265671705, 0.604435823473, 0.565352679646, 0.537608804383, 0.51849505465, 0.506508536474, 0.500715908905]],\n    f3dB: [[1.27201964951], [1.60335751622, 1.43017155999], [1.9047076123, 1.68916826762, 1.60391912877], [2.18872623053, 1.95319575902, 1.8320926012, 1.77846591177], [2.45062684305, 2.20375262593, 2.06220731793, 1.98055310881, 1.94270419166], [2.69298925084, 2.43912611431, 2.28431825401, 2.18496722634, 2.12472538477, 2.09613322542], [2.91905714471, 2.66069088948, 2.49663434571, 2.38497976939, 2.30961462222, 2.26265746534, 2.24005716132], [3.13149167404, 2.87016099416, 2.69935018044, 2.57862945683, 2.49225505119, 2.43227707449, 2.39427710712, 2.37582307687], [3.33237300564, 3.06908580184, 2.89318259511, 2.76551588399, 2.67073340527, 2.60094950474, 2.55161764546, 2.52001358804, 2.50457164552], [3.52333123464, 3.25877569704, 3.07894353744, 2.94580435024, 2.84438325189, 2.76691082498, 2.70881411245, 2.66724655259, 2.64040228249, 2.62723439989], [3.70566068548, 3.44032173223, 3.2574059854, 3.11986367838, 3.01307175388, 2.92939234605, 2.86428726094, 2.81483068055, 2.77915465405, 2.75596888377, 2.74456638588], [3.88040469682, 3.61463243697, 3.4292654707, 3.28812274966, 3.17689762788, 3.08812364257, 3.01720732972, 2.96140104561, 2.91862858495, 2.88729479473, 2.8674198668, 2.8570800015]],\n    f1dB: [[2.16477559371], [2.70320928596, 2.41122332505], [3.25676581436, 2.88822569572, 2.74246238837], [3.76153580353, 3.35675411406, 3.14862673032, 3.05646412475], [4.22174260104, 3.79644757806, 3.55260471864, 3.41193742197, 3.34673435508], [4.64584812552, 4.20789257981, 3.94082363122, 3.76942681446, 3.66549975744, 3.61617359345], [5.04060395196, 4.5944592201, 4.3111677248, 4.11836351827, 3.98822359814, 3.90713836715, 3.86811234525], [5.41107948467, 4.95951159709, 4.66435804468, 4.45575796102, 4.30650679478, 4.20286750045, 4.13720522991, 4.10531748119], [5.76110791853, 5.30592898465, 5.00182215701, 4.7811081045, 4.61724509926, 4.49660100894, 4.41131378918, 4.35667671372, 4.32997951075], [6.09364309488, 5.63609116014, 5.32506930789, 5.09480346139, 4.91939504255, 4.78540258409, 4.68493280536, 4.61302286993, 4.56661931366, 4.54382759952], [6.41100731543, 5.95195558182, 5.63550073656, 5.39754464742, 5.21278891332, 5.06801430334, 4.95539684456, 4.8697869429, 4.80814951843, 4.76793469612, 4.74828032403], [6.71506056052, 6.25514029778, 5.9343616072, 5.69011422355, 5.49763642361, 5.34401973764, 5.22125973611, 5.12485045619, 5.05037962112, 4.99699982231, 4.96155789635, 4.94441828777]]\n  }\n};\n\n// from Texas Instruments \"Op Amps for Everyone\" Chapter 16 \"Active Filter Design Techniques\"\nvar tiTable = {\n  bessel: {\n    as: [[1.3617], [1.3397, 0.7743], [1.2217, 0.9686, 0.5131], [1.1112, 0.9754, 0.7202, 0.3728], [1.0215, 0.9393, 0.7815, 0.5604, 0.2883]],\n    bs: [[0.6180], [0.4889, 0.3890], [0.3887, 0.3505, 0.2756], [0.3162, 0.2979, 0.2621, 0.2087], [0.2650, 0.2549, 0.2351, 0.2059, 0.1665]]\n  },\n  butterworth: {\n    as: [[1.4142], [1.8478, 0.7654], [1.9319, 1.4142, 0.5176], [1.9616, 1.6629, 1.1111, 0.3902], [1.9754, 1.7820, 1.4142, 0.9080, 0.3129]],\n    bs: [[1.0], [1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0, 1.0]]\n  },\n  tschebyscheff05: {\n    as: [[1.3614], [2.6282, 0.3648], [3.8645, 0.7528, 0.1589], [5.1117, 1.0639, 0.3439, 0.0885], [6.3648, 1.3582, 0.4822, 0.1994, 0.0563]],\n    bs: [[1.3827], [3.4341, 1.1509], [6.9797, 1.8573, 1.0711], [11.9607, 2.9365, 1.4206, 1.0407], [18.3695, 4.3453, 1.9440, 1.2520, 1.0263]]\n  },\n  tschebyscheff1: {\n    as: [[1.3022], [2.5904, 0.3039], [3.8437, 0.6292, 0.1296], [5.1019, 0.8916, 0.2806, 0.0717], [6.3634, 1.1399, 0.3939, 0.1616, 0.0455]],\n    bs: [[1.5515], [4.1301, 1.1697], [8.5529, 1.9124, 1.0766], [14.7608, 3.0426, 1.4334, 1.0432], [22.7468, 4.5167, 1.9665, 1.2569, 1.0277]]\n  },\n  tschebyscheff2: {\n    as: [[1.1813], [2.4025, 0.2374], [3.5880, 0.4925, 0.0995], [4.7743, 0.6991, 0.2153, 0.0547], [5.9618, 0.8947, 0.3023, 0.1233, 0.0347]],\n    bs: [[1.7775], [4.9862, 1.1896], [10.4648, 1.9622, 1.0826], [18.1510, 3.1353, 1.4449, 1.0461], [28.0376, 4.6644, 1.9858, 1.2614, 1.0294]]\n  },\n  tschebyscheff3: {\n    as: [[1.0650], [2.1853, 0.1964], [3.2721, 0.4077, 0.0815], [4.3583, 0.5791, 0.1765, 0.0448], [5.4449, 0.7414, 0.2479, 0.1008, 0.0283]],\n    bs: [[1.9305], [5.5339, 1.2009], [11.6773, 1.9873, 1.0861], [20.2948, 3.1808, 1.4507, 1.0478], [31.3788, 4.7363, 1.9952, 1.2638, 1.0304]]\n  },\n  allpass: {\n    as: [[1.6278], [2.3370, 1.3506], [2.6117, 2.0706, 1.0967], [2.7541, 2.4174, 1.7850, 0.9239], [2.8406, 2.6120, 2.1733, 1.5583, 0.8018]],\n    bs: [[0.8832], [1.4878, 1.1837], [1.7763, 1.6015, 1.2596], [1.9420, 1.8300, 1.6101, 1.2822], [2.0490, 1.9714, 1.8184, 1.5923, 1.2877]]\n  }\n};\n\nvar calcCoeffs = function calcCoeffs(params, behavior) {\n  var filter = [];\n  var cnt = 0;\n  if (behavior !== 'fromPZ') {\n    if (params.order > 12) {\n      params.order = 12;\n    }\n    for (cnt = 0; cnt < params.order; cnt++) {\n      var q, f, fd;\n      if (params.transform === 'matchedZ') {\n        filter.push(getCoeffs['lowpassMZ']({\n          Fs: params.Fs,\n          Fc: params.Fc,\n          preGain: params.preGain,\n          as: tiTable[params.characteristic].as[params.order - 1][cnt],\n          bs: tiTable[params.characteristic].bs[params.order - 1][cnt]\n        }));\n      } else {\n        if (params.characteristic === 'butterworth') {\n          q = 0.5 / Math.sin(Math.PI / (params.order * 2) * (cnt + 0.5));\n          f = 1;\n        } else {\n          q = table[params.characteristic].q[params.order - 1][cnt];\n          if (params.oneDb) {\n            f = table[params.characteristic].f1dB[params.order - 1][cnt];\n          } else {\n            f = table[params.characteristic].f3dB[params.order - 1][cnt];\n          }\n        }\n\n        if (behavior === 'highpass') {\n          fd = params.Fc / f;\n        } else {\n          fd = params.Fc * f;\n        }\n        if (behavior === 'bandpass' || behavior === 'bandstop') {\n          if (params.characteristic === 'bessel') {\n            fd = Math.sqrt(params.order) * fd / params.order;\n          }\n        }\n        filter.push(getCoeffs[behavior]({\n          Fs: params.Fs,\n          Fc: fd,\n          Q: q,\n          BW: params.BW || 0,\n          gain: params.gain || 0,\n          preGain: params.preGain || false\n        }));\n      }\n    }\n  } else {\n    for (cnt = 0; cnt < params.length; cnt++) {\n      filter.push(getCoeffs[behavior](params[cnt]));\n    }\n  }\n\n  return filter;\n};\n\nvar initCalcCoeffs = function initCalcCoeffs(behavior) {\n  return function (params) {\n    return calcCoeffs(params, behavior);\n  };\n};\n\nvar self = {};\nvar CalcCascades = function CalcCascades() {\n  var available = [];\n  for (var k in getCoeffs) {\n    self[k] = initCalcCoeffs(k);\n    available.push(k);\n  }\n  self.available = function () {\n    return available;\n  };\n  return self;\n};\n\nmodule.exports = CalcCascades;\n\n},{\"./iirCoeffs\":6}],3:[function(require,module,exports){\n'use strict';\n\nvar Fft = function Fft(radix) {\n  var isPowerOfTwo = function isPowerOfTwo(value) {\n    if (!(value & value - 1)) {\n      return true;\n    }\n    return false;\n  };\n\n  if (!isPowerOfTwo(radix)) {\n    return false;\n  }\n\n  var fft = {};\n  fft.length = radix;\n  fft.buffer = new Float64Array(radix);\n  fft.re = new Float64Array(radix);\n  fft.im = new Float64Array(radix);\n  fft.reI = new Float64Array(radix);\n  fft.imI = new Float64Array(radix);\n\n  fft.twiddle = new Int32Array(radix);\n  fft.sinTable = new Float64Array(radix - 1);\n  fft.cosTable = new Float64Array(radix - 1);\n  var TPI = 2 * Math.PI;\n  var bits = Math.floor(Math.log(radix) / Math.LN2);\n\n  for (i = fft.sinTable.length; i--;) {\n    fft.sinTable[i] = Math.sin(TPI * (i / radix));\n    fft.cosTable[i] = Math.cos(TPI * (i / radix));\n  }\n\n  var nh = radix >> 1;\n  var i = 0;\n  var j = 0;\n  for (;;) {\n    fft.twiddle[i] = j;\n    if (++i >= radix) {\n      break;\n    }\n    bits = nh;\n    while (bits <= j) {\n      j -= bits;\n      bits >>= 1;\n    }\n    j += bits;\n  }\n\n  // good explanation in https://holometer.fnal.gov/GH_FFT.pdf\n\n  var PI = Math.PI;\n  var PI2 = Math.PI * 2;\n  var abs = Math.abs;\n  var pow = Math.pow;\n  var cos = Math.cos;\n  var sin = Math.sin;\n  var sinc = function sinc(x) {\n    return sin(PI * x) / (PI * x);\n  };\n  var E = Math.E;\n\n  var windowCalculation = {\n    rectangular: {\n      calc: function calc() {\n        return 1;\n      },\n      values: [],\n      correction: 1\n    },\n    none: {\n      calc: function calc() {\n        return 1;\n      },\n      values: [],\n      correction: 1\n    },\n    hanning: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.5 * (1 - cos(z));\n      },\n      values: [],\n      correction: 2\n    },\n    hamming: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.54 - 0.46 * cos(z);\n      },\n      values: [],\n      correction: 1.8518999946875638\n    },\n    tukery: {\n      calc: function calc(n, N, a) {\n        if (n < a * (N - 1) / 2) {\n          return 0.5 * (1 + cos(PI * (2 * n / (a * (N - 1)) - 1)));\n        } else if ((N - 1) * (1 - a / 2) < n) {\n          return 0.5 * (1 + cos(PI * (2 * n / (a * (N - 1)) - 2 / a + 1)));\n        } else {\n          return 1;\n        }\n      },\n      values: [],\n      correction: 4 / 3\n    },\n    cosine: {\n      calc: function calc(n, N) {\n        return sin(PI * n / (N - 1));\n      },\n      values: [],\n      correction: 1.570844266360796\n    },\n    lanczos: {\n      calc: function calc(n, N) {\n        return sinc(2 * n / (N - 1) - 1);\n      },\n      values: [],\n      correction: 1.6964337576195783\n    },\n    triangular: {\n      calc: function calc(n, N) {\n        return 2 / (N + 1) * ((N + 1) / 2 - abs(n - (N - 1) / 2));\n      },\n      values: [],\n      correction: 2\n    },\n    bartlett: {\n      calc: function calc(n, N) {\n        return 2 / (N - 1) * ((N - 1) / 2 - abs(n - (N - 1) / 2));\n      },\n      values: [],\n      correction: 2\n    },\n    gaussian: {\n      calc: function calc(n, N, a) {\n        return pow(E, -0.5 * pow((n - (N - 1) / 2) / (a * (N - 1) / 2), 2));\n      },\n      values: [],\n      correction: 5 / 3\n    },\n    bartlettHanning: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.62 - 0.48 * abs(n / (N - 1) - 0.5) - 0.38 * cos(z);\n      },\n      values: [],\n      correction: 2\n    },\n    blackman: {\n      calc: function calc(n, N, a) {\n        var a0 = (1 - a) / 2;\n        var a1 = 0.5;\n        var a2 = a / 2;\n        var z = PI2 * n / (N - 1);\n        return a0 - a1 * cos(z) + a2 * cos(2 * z);\n      },\n      values: [],\n      correction: 4 / 3\n    },\n    blackmanHarris: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.35875 - 0.48829 * cos(z) + 0.14128 * cos(2 * z) - 0.01168 * cos(3 * z);\n      },\n      values: [],\n      correction: 1.5594508635\n    },\n    nuttall3: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.375 - 0.5 * cos(z) + 0.125 * cos(2 * z);\n      },\n      values: [],\n      correction: 1.56\n    },\n    nuttall3a: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.40897 - 0.5 * cos(z) + 0.09103 * cos(2 * z);\n      },\n      values: [],\n      correction: 1.692\n    },\n    nuttall3b: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.4243801 - 0.4973406 * cos(z) + 0.078793 * cos(2 * z);\n      },\n      values: [],\n      correction: 1.7372527\n    },\n    nuttall4: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.3125 - 0.46875 * cos(z) + 0.1875 * cos(2 * z) - 0.03125 * cos(3 * z);\n      },\n      values: [],\n      correction: 1.454543\n    },\n    nuttall4a: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.338946 - 0.481973 * cos(z) + 0.161054 * cos(2 * z) - 0.018027 * cos(3 * z);\n      },\n      values: [],\n      correction: 1.512732763\n    },\n    nuttall4b: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.355768 - 0.481973 * cos(z) + 0.144232 * cos(2 * z) - 0.012604 * cos(3 * z);\n      },\n      values: [],\n      correction: 1.55223262\n    },\n    nuttall4c: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.3635819 - 0.4891775 * cos(z) + 0.1365995 * cos(2 * z) - 0.0106411 * cos(3 * z);\n      },\n      values: [],\n      correction: 1.57129067\n    },\n    // fast decaying flat top\n    sft3f: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.26526 - 0.5 * cos(z) + 0.23474 * cos(2 * z);\n      },\n      values: [],\n      correction: 1.3610238\n    },\n    sft4f: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.21706 - 0.42103 * cos(z) + 0.28294 * cos(2 * z) - 0.07897 * cos(3 * z);\n      },\n      values: [],\n      correction: 1.2773573\n    },\n    sft5f: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.1881 - 0.36923 * cos(z) + 0.28702 * cos(2 * z) - 0.13077 * cos(3 * z) + 0.02488 * cos(4 * z);\n      },\n      values: [],\n      correction: 1.23167769\n    },\n    // minimum sidelobe flat top\n    sft3m: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.28235 - 0.52105 * cos(z) + 0.19659 * cos(2 * z);\n      },\n      values: [],\n      correction: 1.39343451\n    },\n    sft4m: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.241906 - 0.460841 * cos(z) + 0.2552381 * cos(2 * z) - 0.041872 * cos(3 * z);\n      },\n      values: [],\n      correction: 1.3190596\n    },\n    sft5m: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.209671 - 0.407331 * cos(z) + 0.281225 * cos(2 * z) - 0.092669 * cos(3 * z) + 0.0091036 * cos(4 * z);\n      },\n      values: [],\n      correction: 1.26529456464\n    },\n    nift: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return 0.2810639 - 0.5208972 * cos(z) + 0.1980399 * cos(2 * z);\n      },\n      values: [],\n      correction: 1.39094182\n    },\n    hpft: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return (1.0 - 1.912510941 * cos(z) + 1.079173272 * cos(2 * z) - 0.1832630879 * cos(3 * z)) / N;\n      },\n      values: [],\n      correction: 1\n    },\n    srft: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return (1.0 - 1.93 * cos(z) + 1.29 * cos(2 * z) - 0.388 * cos(3 * z) + 0.028 * cos(4 * z)) / N;\n      },\n      values: [],\n      correction: 1\n    },\n    hft70: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return (1.0 - 1.90796 * cos(z) + 1.07349 * cos(2 * z) - 0.18199 * cos(3 * z)) / N;\n      },\n      values: [],\n      correction: 1\n    },\n    hft95: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return (1.0 - 1.9383379 * cos(z) + 1.3045202 * cos(2 * z) - 0.402827 * cos(3 * z) + 0.0350665 * cos(4 * z)) / N;\n      },\n      values: [],\n      correction: 1\n    },\n    hft90d: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return (1.0 - 1.942604 * cos(z) + 1.340318 * cos(2 * z) - 0.440811 * cos(3 * z) + 0.043097 * cos(4 * z)) / N;\n      },\n      values: [],\n      correction: 1\n    },\n    hft116d: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return (1.0 - 1.9575375 * cos(z) + 1.4780705 * cos(2 * z) - 0.6367431 * cos(3 * z) + 0.1228389 * cos(4 * z) - 0.0066288 * cos(5 * z)) / N;\n      },\n      values: [],\n      correction: 1\n    },\n    hft144d: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return (1.0 - 1.96760033 * cos(z) + 1.57983607 * cos(2 * z) - 0.81123644 * cos(3 * z) + 0.22583558 * cos(4 * z) - 0.02773848 * cos(5 * z) + 0.0009036 * cos(6 * z)) / N;\n      },\n      values: [],\n      correction: 1\n    },\n    hft196d: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return (1.0 - 1.97441842 * cos(z) + 1.65409888 * cos(2 * z) - 0.95788186 * cos(3 * z) + 0.3367342 * cos(4 * z) - 0.06364621 * cos(5 * z) + 0.00521942 * cos(6 * z) - 0.00010599 * cos(7 * z)) / N;\n      },\n      values: [],\n      correction: 1\n    },\n    hft223d: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return (1.0 - 1.98298997309 * cos(z) + 1.75556083063 * cos(2 * z) - 1.19037717712 * cos(3 * z) + 0.56155440797 * cos(4 * z) - 0.17296769663 * cos(5 * z) + 0.03233247087 * cos(6 * z) - 0.00324954578 * cos(7 * z) + 0.00013801040 * cos(8 * z) - 0.00000132725 * cos(9 * z)) / N;\n      },\n      values: [],\n      correction: 1\n    },\n    hft248d: {\n      calc: function calc(n, N) {\n        var z = PI2 * n / (N - 1);\n        return (1.0 - 1.985844164102 * cos(z) + 1.791176438506 * cos(2 * z) - 1.282075284005 * cos(3 * z) + 0.667777530266 * cos(4 * z) - 0.240160796576 * cos(5 * z) + 0.056656381764 * cos(6 * z) - 0.008134974479 * cos(7 * z) + 0.00062454465 * cos(8 * z) - 0.000019808998 * cos(9 * z) + 0.000000132974 * cos(10 * z)) / N;\n      },\n      values: [],\n      correction: 1\n    }\n  };\n\n  var windowFunctions = function windowFunctions(params) {\n    if (windowCalculation[params.name].values.length !== params.N) {\n      if (params.n === 0) {\n        windowCalculation[params.name].values.length = 0;\n      }\n      windowCalculation[params.name].values[params.n] = windowCalculation[params.name].correction * windowCalculation[params.name].calc(params.n, params.N, params.a);\n      return windowCalculation[params.name].values[params.n];\n    }\n    return windowCalculation[params.name].values;\n  };\n\n  var self = {\n    forward: function forward(b, window) {\n      var i, j, n, k, k2, h, d, c, s, ik, dx, dy;\n      n = fft.buffer.length;\n      var winFunction = {\n        name: window,\n        N: n,\n        a: 0.5,\n        n: 0\n      };\n      var w = windowFunctions(winFunction);\n      if (typeof w === 'number') {\n        for (i = 0; i < n; ++i) {\n          winFunction.n = i;\n          fft.buffer[i] = b[i] * windowFunctions(winFunction);\n        }\n      } else {\n        for (i = 0; i < n; ++i) {\n          fft.buffer[i] = b[i] * w[i];\n        }\n      }\n\n      for (i = n; i--;) {\n        fft.re[i] = fft.buffer[fft.twiddle[i]];\n        fft.im[i] = 0.0;\n      }\n\n      for (k = 1; k < n; k = k2) {\n        h = 0;\n        k2 = k + k;\n        d = n / k2;\n        for (j = 0; j < k; j++) {\n          c = fft.cosTable[h];\n          s = fft.sinTable[h];\n          for (i = j; i < n; i += k2) {\n            ik = i + k;\n            dx = s * fft.im[ik] + c * fft.re[ik];\n            dy = c * fft.im[ik] - s * fft.re[ik];\n            fft.re[ik] = fft.re[i] - dx;\n            fft.re[i] += dx;\n            fft.im[ik] = fft.im[i] - dy;\n            fft.im[i] += dy;\n          }\n          h += d;\n        }\n      }\n      return {\n        re: fft.re,\n        im: fft.im\n      };\n    },\n    inverse: function inverse(re, im) {\n      var i, j, n, k, k2, h, d, c, s, ik, dx, dy;\n      n = re.length;\n      for (i = n; i--;) {\n        j = fft.twiddle[i];\n        fft.reI[i] = re[j];\n        fft.imI[i] = -im[j];\n      }\n\n      for (k = 1; k < n; k = k2) {\n        h = 0;\n        k2 = k + k;\n        d = n / k2;\n        for (j = 0; j < k; j++) {\n          c = fft.cosTable[h];\n          s = fft.sinTable[h];\n          for (i = j; i < n; i += k2) {\n            ik = i + k;\n            dx = s * fft.imI[ik] + c * fft.reI[ik];\n            dy = c * fft.imI[ik] - s * fft.reI[ik];\n            fft.reI[ik] = fft.reI[i] - dx;\n            fft.reI[i] += dx;\n            fft.imI[ik] = fft.imI[i] - dy;\n            fft.imI[i] += dy;\n          }\n          h += d;\n        }\n      }\n\n      for (i = n; i--;) {\n        fft.buffer[i] = fft.reI[i] / n;\n      }\n      return fft.buffer;\n    },\n    magnitude: function magnitude(params) {\n      var ret = [];\n      for (var cnt = 0; cnt < params.re.length; cnt++) {\n        ret.push(Math.sqrt(params.re[cnt] * params.re[cnt] + params.im[cnt] * params.im[cnt]));\n      }\n      return ret;\n    },\n    magToDb: function magToDb(b) {\n      var ret = [];\n      for (var cnt = 0; cnt < b.length; cnt++) {\n        ret.push(20 * Math.log(b[cnt]) * Math.LOG10E);\n      }\n      return ret;\n    },\n    phase: function phase(params) {\n      var ret = [];\n      for (var cnt = 0; cnt < params.re.length; cnt++) {\n        ret.push(Math.atan2(params.im[cnt], params.re[cnt]));\n      }\n      return ret;\n    },\n    windows: function windows() {\n      var winFuncs = [];\n      for (var k in windowCalculation) {\n        winFuncs.push(k);\n      }\n      return winFuncs;\n    }\n  };\n  return self;\n};\n\nmodule.exports = Fft;\n\n},{}],4:[function(require,module,exports){\n'use strict';\n\nvar FirCoeffs = function FirCoeffs() {\n  // Kaiser windowd filters\n  // desired attenuation can be defined\n  // better than windowd sinc filters\n  var calcKImpulseResponse = function calcKImpulseResponse(params) {\n    var Fs = params.Fs;\n    var Fa = params.Fa;\n    var Fb = params.Fb;\n    var o = params.order || 51;\n    var alpha = params.Att || 100;\n    var ino = function ino(val) {\n      var d = 0;\n      var ds = 1;\n      var s = 1;\n      while (ds > s * 1e-6) {\n        d += 2;\n        ds *= val * val / (d * d);\n        s += ds;\n      }\n      return s;\n    };\n\n    if (o / 2 - Math.floor(o / 2) === 0) {\n      o++;\n    }\n    var Np = (o - 1) / 2;\n    var A = [];\n    var beta = 0;\n    var cnt = 0;\n    var inoBeta;\n    var ret = [];\n\n    A[0] = 2 * (Fb - Fa) / Fs;\n    for (cnt = 1; cnt <= Np; cnt++) {\n      A[cnt] = (Math.sin(2 * cnt * Math.PI * Fb / Fs) - Math.sin(2 * cnt * Math.PI * Fa / Fs)) / (cnt * Math.PI);\n    }\n    // empirical coefficients\n    if (alpha < 21) {\n      beta = 0;\n    } else if (alpha > 50) {\n      beta = 0.1102 * (alpha - 8.7);\n    } else {\n      beta = 0.5842 * Math.pow(alpha - 21, 0.4) + 0.07886 * (alpha - 21);\n    }\n\n    inoBeta = ino(beta);\n    for (cnt = 0; cnt <= Np; cnt++) {\n      ret[Np + cnt] = A[cnt] * ino(beta * Math.sqrt(1 - cnt * cnt / (Np * Np))) / inoBeta;\n    }\n    for (cnt = 0; cnt < Np; cnt++) {\n      ret[cnt] = ret[o - 1 - cnt];\n    }\n    return ret;\n  };\n\n  // note: coefficients are equal to impulse response\n  // windowd sinc filter\n  var calcImpulseResponse = function calcImpulseResponse(params) {\n    var Fs = params.Fs;\n    var Fc = params.Fc;\n    var o = params.order;\n    var omega = 2 * Math.PI * Fc / Fs;\n    var cnt = 0;\n    var dc = 0;\n    var ret = [];\n    // sinc function is considered to be\n    // the ideal impulse response\n    // do an idft and use Hamming window afterwards\n    for (cnt = 0; cnt <= o; cnt++) {\n      if (cnt - o / 2 === 0) {\n        ret[cnt] = omega;\n      } else {\n        ret[cnt] = Math.sin(omega * (cnt - o / 2)) / (cnt - o / 2);\n        // Hamming window\n        ret[cnt] *= 0.54 - 0.46 * Math.cos(2 * Math.PI * cnt / o);\n      }\n      dc = dc + ret[cnt];\n    }\n    // normalize\n    for (cnt = 0; cnt <= o; cnt++) {\n      ret[cnt] /= dc;\n    }\n    return ret;\n  };\n  // invert for highpass from lowpass\n  var invert = function invert(h) {\n    var cnt;\n    for (cnt = 0; cnt < h.length; cnt++) {\n      h[cnt] = -h[cnt];\n    }\n    h[(h.length - 1) / 2]++;\n    return h;\n  };\n  var bs = function bs(params) {\n    var lp = calcImpulseResponse({\n      order: params.order,\n      Fs: params.Fs,\n      Fc: params.F2\n    });\n    var hp = invert(calcImpulseResponse({\n      order: params.order,\n      Fs: params.Fs,\n      Fc: params.F1\n    }));\n    var out = [];\n    for (var i = 0; i < lp.length; i++) {\n      out.push(lp[i] + hp[i]);\n    }\n    return out;\n  };\n  var self = {\n    lowpass: function lowpass(params) {\n      return calcImpulseResponse(params);\n    },\n    highpass: function highpass(params) {\n      return invert(calcImpulseResponse(params));\n    },\n    bandstop: function bandstop(params) {\n      return bs(params);\n    },\n    bandpass: function bandpass(params) {\n      return invert(bs(params));\n    },\n    kbFilter: function kbFilter(params) {\n      return calcKImpulseResponse(params);\n    },\n    available: function available() {\n      return ['lowpass', 'highpass', 'bandstop', 'bandpass', 'kbFilter'];\n    }\n  };\n  return self;\n};\n\nmodule.exports = FirCoeffs;\n\n},{}],5:[function(require,module,exports){\n'use strict';\n\nvar _require = require('./utils');\n\nvar runMultiFilter = _require.runMultiFilter;\nvar runMultiFilterReverse = _require.runMultiFilterReverse;\nvar complex = _require.complex;\nvar evaluatePhase = _require.evaluatePhase;\n\n/**\n * Fir filter\n */\nvar FirFilter = function FirFilter(filter) {\n  // note: coefficients are equal to input response\n  var f = filter;\n  var b = [];\n  var cnt = 0;\n  for (cnt = 0; cnt < f.length; cnt++) {\n    b[cnt] = {\n      re: f[cnt],\n      im: 0\n    };\n  }\n\n  var initZero = function initZero(cnt) {\n    var r = [];\n    var i;\n    for (i = 0; i < cnt; i++) {\n      r.push(0);\n    }\n    return {\n      buf: r,\n      pointer: 0\n    };\n  };\n\n  var z = initZero(f.length - 1);\n\n  var doStep = function doStep(input, d) {\n    d.buf[d.pointer] = input;\n    var out = 0;\n    for (cnt = 0; cnt < d.buf.length; cnt++) {\n      out += f[cnt] * d.buf[(d.pointer + cnt) % d.buf.length];\n    }\n    d.pointer = (d.pointer + 1) % d.buf.length;\n    return out;\n  };\n\n  var calcInputResponse = function calcInputResponse(input) {\n    var tempF = initZero(f.length - 1);\n    return runMultiFilter(input, tempF, doStep);\n  };\n\n  var calcResponse = function calcResponse(params) {\n    var Fs = params.Fs;\n    var Fr = params.Fr;\n    // z = exp(j*omega*pi) = cos(omega*pi) + j*sin(omega*pi)\n    // z^-1 = exp(-j*omega*pi)\n    // omega is between 0 and 1. 1 is the Nyquist frequency.\n    var theta = -Math.PI * (Fr / Fs) * 2;\n    var h = {\n      re: 0,\n      im: 0\n    };\n    for (var i = 0; i < f.length - 1; i++) {\n      h = complex.add(h, complex.mul(b[i], {\n        re: Math.cos(theta * i),\n        im: Math.sin(theta * i)\n      }));\n    }\n    var m = complex.magnitude(h);\n    var res = {\n      magnitude: m,\n      phase: complex.phase(h),\n      dBmagnitude: 20 * Math.log(m) * Math.LOG10E\n    };\n    return res;\n  };\n\n  var self = {\n    responsePoint: function responsePoint(params) {\n      return calcResponse(params);\n    },\n    response: function response(resolution) {\n      resolution = resolution || 100;\n      var res = [];\n      var cnt = 0;\n      var r = resolution * 2;\n      for (cnt = 0; cnt < resolution; cnt++) {\n        res[cnt] = calcResponse({\n          Fs: r,\n          Fr: cnt\n        });\n      }\n      evaluatePhase(res);\n      return res;\n    },\n    simulate: function simulate(input) {\n      return calcInputResponse(input);\n    },\n    singleStep: function singleStep(input) {\n      return doStep(input, z);\n    },\n    multiStep: function multiStep(input, overwrite) {\n      return runMultiFilter(input, z, doStep, overwrite);\n    },\n    filtfilt: function filtfilt(input, overwrite) {\n      return runMultiFilterReverse(runMultiFilter(input, z, doStep, overwrite), z, doStep, true);\n    },\n    reinit: function reinit() {\n      z = initZero(f.length - 1);\n    }\n  };\n  return self;\n};\n\nmodule.exports = FirFilter;\n\n},{\"./utils\":9}],6:[function(require,module,exports){\n'use strict';\n\nvar IirCoeffs = function IirCoeffs() {\n  var preCalc = function preCalc(params, coeffs) {\n    var Q = params.Q;\n    var Fc = params.Fc;\n    var Fs = params.Fs;\n    var pre = {};\n    var w = 2 * Math.PI * Fc / Fs;\n    if (params.BW) {\n      pre.alpha = Math.sin(w) * Math.sinh(Math.log(2) / 2 * params.BW * w / Math.sin(w));\n    } else {\n      pre.alpha = Math.sin(w) / (2 * Q);\n    }\n    pre.cw = Math.cos(w);\n    pre.a0 = 1 + pre.alpha;\n    coeffs.a0 = pre.a0;\n    coeffs.a.push(-2 * pre.cw / pre.a0);\n    coeffs.k = 1;\n    coeffs.a.push((1 - pre.alpha) / pre.a0);\n    return pre;\n  };\n\n  var preCalcGain = function preCalcGain(params) {\n    var Q = params.Q;\n    var Fc = params.Fc;\n    var Fs = params.Fs;\n    var pre = {};\n    var w = 2 * Math.PI * Fc / Fs;\n    pre.alpha = Math.sin(w) / (2 * Q);\n    pre.cw = Math.cos(w);\n    pre.A = Math.pow(10, params.gain / 40);\n    return pre;\n  };\n\n  var initCoeffs = function initCoeffs() {\n    var coeffs = {};\n    coeffs.z = [0, 0];\n    coeffs.a = [];\n    coeffs.b = [];\n    return coeffs;\n  };\n\n  var self = {\n\n    fromPZ: function fromPZ(params) {\n      var coeffs = initCoeffs();\n      coeffs.a0 = 1;\n      coeffs.b.push(1);\n      coeffs.b.push(-params.z0.re - params.z1.re);\n      coeffs.b.push(params.z0.re * params.z1.re - params.z0.im * params.z1.im);\n      coeffs.a.push(-params.p0.re - params.p1.re);\n      coeffs.a.push(params.p0.re * params.p1.re - params.p0.im * params.p1.im);\n      if (params.type === 'lowpass') {\n        coeffs.k = (1 + coeffs.a[0] + coeffs.a[1]) / (1 + coeffs.b[1] + coeffs.b[2]);\n      } else {\n        coeffs.k = (1 - coeffs.a[0] + coeffs.a[1]) / (1 - coeffs.b[1] + coeffs.b[2]);\n      }\n      return coeffs;\n    },\n\n    // lowpass matched-z transform: H(s) = 1/(1+a's/w_c+b's^2/w_c)\n    lowpassMZ: function lowpassMZ(params) {\n      var coeffs = initCoeffs();\n      coeffs.a0 = 1;\n      var as = params.as;\n      var bs = params.bs;\n      var w = 2 * Math.PI * params.Fc / params.Fs;\n      var s = -(as / (2 * bs));\n      coeffs.a.push(-Math.pow(Math.E, s * w) * 2 * Math.cos(-w * Math.sqrt(Math.abs(Math.pow(as, 2) / (4 * Math.pow(bs, 2)) - 1 / bs))));\n      coeffs.a.push(Math.pow(Math.E, 2 * s * w));\n      // correct gain\n      if (!params.preGain) {\n        coeffs.b.push(coeffs.a0 + coeffs.a[0] + coeffs.a[1]);\n        coeffs.k = 1;\n      } else {\n        coeffs.b.push(1);\n        coeffs.k = coeffs.a0 + coeffs.a[0] + coeffs.a[1];\n      }\n      coeffs.b.push(0);\n      coeffs.b.push(0);\n      return coeffs;\n    },\n\n    // Bessel-Thomson: H(s) = 3/(s^2+3*s+3)\n    lowpassBT: function lowpassBT(params) {\n      var coeffs = initCoeffs();\n      params.Q = 1;\n      coeffs.wp = Math.tan(2 * Math.PI * params.Fc / (2 * params.Fs));\n      coeffs.wp2 = coeffs.wp * coeffs.wp;\n      if (params.BW) {\n        delete params.BW;\n      }\n      coeffs.k = 1;\n      coeffs.a0 = 3 * coeffs.wp + 3 * coeffs.wp2 + 1;\n      coeffs.b.push(3 * coeffs.wp2 * params.Q / coeffs.a0);\n      coeffs.b.push(2 * coeffs.b[0]);\n      coeffs.b.push(coeffs.b[0]);\n      coeffs.a.push((6 * coeffs.wp2 - 2) / coeffs.a0);\n      coeffs.a.push((3 * coeffs.wp2 - 3 * coeffs.wp + 1) / coeffs.a0);\n      return coeffs;\n    },\n\n    highpassBT: function highpassBT(params) {\n      var coeffs = initCoeffs();\n      params.Q = 1;\n      coeffs.wp = Math.tan(2 * Math.PI * params.Fc / (2 * params.Fs));\n      coeffs.wp2 = coeffs.wp * coeffs.wp;\n      if (params.BW) {\n        delete params.BW;\n      }\n      coeffs.k = 1;\n      coeffs.a0 = coeffs.wp + coeffs.wp2 + 3;\n      coeffs.b.push(3 * params.Q / coeffs.a0);\n      coeffs.b.push(2 * coeffs.b[0]);\n      coeffs.b.push(coeffs.b[0]);\n      coeffs.a.push((2 * coeffs.wp2 - 6) / coeffs.a0);\n      coeffs.a.push((coeffs.wp2 - coeffs.wp + 3) / coeffs.a0);\n      return coeffs;\n    },\n\n    /*\n     * Formulas from http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt\n     */\n    // H(s) = 1 / (s^2 + s/Q + 1)\n    lowpass: function lowpass(params) {\n      var coeffs = initCoeffs();\n      if (params.BW) {\n        delete params.BW;\n      }\n      var p = preCalc(params, coeffs);\n      if (params.preGain) {\n        coeffs.k = (1 - p.cw) * 0.5;\n        coeffs.b.push(1 / p.a0);\n      } else {\n        coeffs.k = 1;\n        coeffs.b.push((1 - p.cw) / (2 * p.a0));\n      }\n      coeffs.b.push(2 * coeffs.b[0]);\n      coeffs.b.push(coeffs.b[0]);\n      return coeffs;\n    },\n\n    // H(s) = s^2 / (s^2 + s/Q + 1)\n    highpass: function highpass(params) {\n      var coeffs = initCoeffs();\n      if (params.BW) {\n        delete params.BW;\n      }\n      var p = preCalc(params, coeffs);\n      if (params.preGain) {\n        coeffs.k = (1 + p.cw) * 0.5;\n        coeffs.b.push(1 / p.a0);\n      } else {\n        coeffs.k = 1;\n        coeffs.b.push((1 + p.cw) / (2 * p.a0));\n      }\n      coeffs.b.push(-2 * coeffs.b[0]);\n      coeffs.b.push(coeffs.b[0]);\n      return coeffs;\n    },\n\n    // H(s) = (s^2 - s/Q + 1) / (s^2 + s/Q + 1)\n    allpass: function allpass(params) {\n      var coeffs = initCoeffs();\n      if (params.BW) {\n        delete params.BW;\n      }\n      var p = preCalc(params, coeffs);\n      coeffs.k = 1;\n      coeffs.b.push((1 - p.alpha) / p.a0);\n      coeffs.b.push(-2 * p.cw / p.a0);\n      coeffs.b.push((1 + p.alpha) / p.a0);\n      return coeffs;\n    },\n\n    // H(s) = s / (s^2 + s/Q + 1)\n    bandpassQ: function bandpassQ(params) {\n      var coeffs = initCoeffs();\n      var p = preCalc(params, coeffs);\n      coeffs.k = 1;\n      coeffs.b.push(p.alpha * params.Q / p.a0);\n      coeffs.b.push(0);\n      coeffs.b.push(-coeffs.b[0]);\n      return coeffs;\n    },\n\n    // H(s) = (s/Q) / (s^2 + s/Q + 1)\n    bandpass: function bandpass(params) {\n      var coeffs = initCoeffs();\n      var p = preCalc(params, coeffs);\n      coeffs.k = 1;\n      coeffs.b.push(p.alpha / p.a0);\n      coeffs.b.push(0);\n      coeffs.b.push(-coeffs.b[0]);\n      return coeffs;\n    },\n\n    // H(s) = (s^2 + 1) / (s^2 + s/Q + 1)\n    bandstop: function bandstop(params) {\n      var coeffs = initCoeffs();\n      var p = preCalc(params, coeffs);\n      coeffs.k = 1;\n      coeffs.b.push(1 / p.a0);\n      coeffs.b.push(-2 * p.cw / p.a0);\n      coeffs.b.push(coeffs.b[0]);\n      return coeffs;\n    },\n\n    // H(s) = (s^2 + s*(A/Q) + 1) / (s^2 + s/(A*Q) + 1)\n    peak: function peak(params) {\n      var coeffs = initCoeffs();\n      var p = preCalcGain(params);\n      coeffs.k = 1;\n      coeffs.a0 = 1 + p.alpha / p.A;\n      coeffs.a.push(-2 * p.cw / coeffs.a0);\n      coeffs.a.push((1 - p.alpha / p.A) / coeffs.a0);\n      coeffs.b.push((1 + p.alpha * p.A) / coeffs.a0);\n      coeffs.b.push(-2 * p.cw / coeffs.a0);\n      coeffs.b.push((1 - p.alpha * p.A) / coeffs.a0);\n      return coeffs;\n    },\n\n    // H(s) = A * (s^2 + (sqrt(A)/Q)*s + A)/(A*s^2 + (sqrt(A)/Q)*s + 1)\n    lowshelf: function lowshelf(params) {\n      var coeffs = initCoeffs();\n      if (params.BW) {\n        delete params.BW;\n      }\n      var p = preCalcGain(params);\n      coeffs.k = 1;\n      var sa = 2 * Math.sqrt(p.A) * p.alpha;\n      coeffs.a0 = p.A + 1 + (p.A - 1) * p.cw + sa;\n      coeffs.a.push(-2 * (p.A - 1 + (p.A + 1) * p.cw) / coeffs.a0);\n      coeffs.a.push((p.A + 1 + (p.A - 1) * p.cw - sa) / coeffs.a0);\n      coeffs.b.push(p.A * (p.A + 1 - (p.A - 1) * p.cw + sa) / coeffs.a0);\n      coeffs.b.push(2 * p.A * (p.A - 1 - (p.A + 1) * p.cw) / coeffs.a0);\n      coeffs.b.push(p.A * (p.A + 1 - (p.A - 1) * p.cw - sa) / coeffs.a0);\n      return coeffs;\n    },\n\n    // H(s) = A * (A*s^2 + (sqrt(A)/Q)*s + 1)/(s^2 + (sqrt(A)/Q)*s + A)\n    highshelf: function highshelf(params) {\n      var coeffs = initCoeffs();\n      if (params.BW) {\n        delete params.BW;\n      }\n      var p = preCalcGain(params);\n      coeffs.k = 1;\n      var sa = 2 * Math.sqrt(p.A) * p.alpha;\n      coeffs.a0 = p.A + 1 - (p.A - 1) * p.cw + sa;\n      coeffs.a.push(2 * (p.A - 1 - (p.A + 1) * p.cw) / coeffs.a0);\n      coeffs.a.push((p.A + 1 - (p.A - 1) * p.cw - sa) / coeffs.a0);\n      coeffs.b.push(p.A * (p.A + 1 + (p.A - 1) * p.cw + sa) / coeffs.a0);\n      coeffs.b.push(-2 * p.A * (p.A - 1 + (p.A + 1) * p.cw) / coeffs.a0);\n      coeffs.b.push(p.A * (p.A + 1 + (p.A - 1) * p.cw - sa) / coeffs.a0);\n      return coeffs;\n    },\n\n    // taken from: Design of digital filters for frequency weightings (A and C) required for risk assessments of workers exposed to noise\n    // use Butterworth one stage IIR filter to get the results from the paper\n    aweighting: function aweighting(params) {\n      var coeffs = initCoeffs();\n      coeffs.k = 1;\n      var wo = 2 * Math.PI * params.Fc / params.Fs;\n      var w = 2 * Math.tan(wo / 2);\n      var Q = params.Q;\n      var wsq = Math.pow(w, 2);\n      coeffs.a0 = 4 * Q + wsq * Q + 2 * w;\n      coeffs.a.push(2 * wsq * Q - 8 * Q);\n      coeffs.a.push(4 * Q + wsq * Q - 2 * w);\n      coeffs.b.push(wsq * Q);\n      coeffs.b.push(2 * wsq * Q);\n      coeffs.b.push(wsq * Q);\n      return coeffs;\n    }\n  };\n\n  return self;\n};\n\nmodule.exports = IirCoeffs;\n\n},{}],7:[function(require,module,exports){\n'use strict';\n\nvar _require = require('./utils');\n\nvar complex = _require.complex;\nvar runMultiFilter = _require.runMultiFilter;\nvar runMultiFilterReverse = _require.runMultiFilterReverse;\nvar evaluatePhase = _require.evaluatePhase;\n\n// params: array of biquad coefficient objects and z registers\n// stage structure e.g. {k:1, a:[1.1, -1.2], b:[0.3, -1.2, -0.4], z:[0, 0]}\nvar IirFilter = function IirFilter(filter) {\n  var f = filter;\n  var cone = {\n    re: 1,\n    im: 0\n  };\n  var cf = [];\n  var cc = [];\n  for (var cnt = 0; cnt < f.length; cnt++) {\n    cf[cnt] = {};\n    var s = f[cnt];\n    cf[cnt].b0 = {\n      re: s.b[0],\n      im: 0\n    };\n    cf[cnt].b1 = {\n      re: s.b[1],\n      im: 0\n    };\n    cf[cnt].b2 = {\n      re: s.b[2],\n      im: 0\n    };\n    cf[cnt].a1 = {\n      re: s.a[0],\n      im: 0\n    };\n    cf[cnt].a2 = {\n      re: s.a[1],\n      im: 0\n    };\n    cf[cnt].k = {\n      re: s.k,\n      im: 0\n    };\n    cf[cnt].z = [0, 0];\n    cc[cnt] = {};\n    cc[cnt].b1 = s.b[1] / s.b[0];\n    cc[cnt].b2 = s.b[2] / s.b[0];\n    cc[cnt].a1 = s.a[0];\n    cc[cnt].a2 = s.a[1];\n  }\n\n  var runStage = function runStage(s, input) {\n    var temp = input * s.k.re - s.a1.re * s.z[0] - s.a2.re * s.z[1];\n    var out = s.b0.re * temp + s.b1.re * s.z[0] + s.b2.re * s.z[1];\n    s.z[1] = s.z[0];\n    s.z[0] = temp;\n    return out;\n  };\n\n  var doStep = function doStep(input, coeffs) {\n    var out = input;\n    var cnt = 0;\n    for (cnt = 0; cnt < coeffs.length; cnt++) {\n      out = runStage(coeffs[cnt], out);\n    }\n    return out;\n  };\n\n  var biquadResponse = function biquadResponse(params, s) {\n    var Fs = params.Fs;\n    var Fr = params.Fr;\n    // z = exp(j*omega*pi) = cos(omega*pi) + j*sin(omega*pi)\n    // z^-1 = exp(-j*omega*pi)\n    // omega is between 0 and 1. 1 is the Nyquist frequency.\n    var theta = -Math.PI * (Fr / Fs) * 2;\n    var z = {\n      re: Math.cos(theta),\n      im: Math.sin(theta)\n    };\n    // k * (b0 + b1*z^-1 + b2*z^-2) / (1 + a1*z^⁻1 + a2*z^-2)\n    var p = complex.mul(s.k, complex.add(s.b0, complex.mul(z, complex.add(s.b1, complex.mul(s.b2, z)))));\n    var q = complex.add(cone, complex.mul(z, complex.add(s.a1, complex.mul(s.a2, z))));\n    var h = complex.div(p, q);\n    var res = {\n      magnitude: complex.magnitude(h),\n      phase: complex.phase(h)\n    };\n    return res;\n  };\n\n  var calcResponse = function calcResponse(params) {\n    var cnt = 0;\n    var res = {\n      magnitude: 1,\n      phase: 0\n    };\n    for (cnt = 0; cnt < cf.length; cnt++) {\n      var r = biquadResponse(params, cf[cnt]);\n      // a cascade of biquads results in the multiplication of H(z)\n      // H_casc(z) = H_0(z) * H_1(z) * ... * H_n(z)\n      res.magnitude *= r.magnitude;\n      // phase is wrapped -> unwrap before using\n      res.phase += r.phase;\n    }\n    res.dBmagnitude = 20 * Math.log(res.magnitude) * Math.LOG10E;\n    return res;\n  };\n\n  var reinit = function reinit() {\n    var tempF = [];\n    for (var cnt = 0; cnt < f.length; cnt++) {\n      tempF[cnt] = {\n        b0: {\n          re: s.b[0],\n          im: 0\n        },\n        b1: {\n          re: s.b[1],\n          im: 0\n        },\n        b2: {\n          re: s.b[2],\n          im: 0\n        },\n        a1: {\n          re: s.a[0],\n          im: 0\n        },\n        a2: {\n          re: s.a[1],\n          im: 0\n        },\n        k: {\n          re: s.k,\n          im: 0\n        },\n        z: [0, 0]\n      };\n    }\n    return tempF;\n  };\n\n  var calcInputResponse = function calcInputResponse(input) {\n    var tempF = reinit();\n    return runMultiFilter(input, tempF, doStep);\n  };\n\n  var predefinedResponse = function predefinedResponse(def, length) {\n    var ret = {};\n    var input = [];\n    var cnt = 0;\n    for (cnt = 0; cnt < length; cnt++) {\n      input.push(def(cnt));\n    }\n    ret.out = calcInputResponse(input);\n    var maxFound = false;\n    var minFound = false;\n    for (cnt = 0; cnt < length - 1; cnt++) {\n      if (ret.out[cnt] > ret.out[cnt + 1] && !maxFound) {\n        maxFound = true;\n        ret.max = {\n          sample: cnt,\n          value: ret.out[cnt]\n        };\n      }\n      if (maxFound && !minFound && ret.out[cnt] < ret.out[cnt + 1]) {\n        minFound = true;\n        ret.min = {\n          sample: cnt,\n          value: ret.out[cnt]\n        };\n        break;\n      }\n    }\n    return ret;\n  };\n\n  var getComplRes = function getComplRes(n1, n2) {\n    var innerSqrt = Math.pow(n1 / 2, 2) - n2;\n    if (innerSqrt < 0) {\n      return [{\n        re: -n1 / 2,\n        im: Math.sqrt(Math.abs(innerSqrt))\n      }, {\n        re: -n1 / 2,\n        im: -Math.sqrt(Math.abs(innerSqrt))\n      }];\n    } else {\n      return [{\n        re: -n1 / 2 + Math.sqrt(innerSqrt),\n        im: 0\n      }, {\n        re: -n1 / 2 - Math.sqrt(innerSqrt),\n        im: 0\n      }];\n    }\n  };\n\n  var getPZ = function getPZ() {\n    var res = [];\n    for (var cnt = 0; cnt < cc.length; cnt++) {\n      res[cnt] = {};\n      res[cnt].z = getComplRes(cc[cnt].b1, cc[cnt].b2);\n      res[cnt].p = getComplRes(cc[cnt].a1, cc[cnt].a2);\n    }\n    return res;\n  };\n\n  var self = {\n    singleStep: function singleStep(input) {\n      return doStep(input, cf);\n    },\n    multiStep: function multiStep(input, overwrite) {\n      return runMultiFilter(input, cf, doStep, overwrite);\n    },\n    filtfilt: function filtfilt(input, overwrite) {\n      return runMultiFilterReverse(runMultiFilter(input, cf, doStep, overwrite), cf, doStep, true);\n    },\n    simulate: function simulate(input) {\n      return calcInputResponse(input);\n    },\n    stepResponse: function stepResponse(length) {\n      return predefinedResponse(function () {\n        return 1;\n      }, length);\n    },\n    impulseResponse: function impulseResponse(length) {\n      return predefinedResponse(function (val) {\n        if (val === 0) {\n          return 1;\n        } else {\n          return 0;\n        }\n      }, length);\n    },\n    responsePoint: function responsePoint(params) {\n      return calcResponse(params);\n    },\n    response: function response(resolution) {\n      resolution = resolution || 100;\n      var res = [];\n      var cnt = 0;\n      var r = resolution * 2;\n      for (cnt = 0; cnt < resolution; cnt++) {\n        res[cnt] = calcResponse({\n          Fs: r,\n          Fr: cnt\n        });\n      }\n      evaluatePhase(res);\n      return res;\n    },\n    polesZeros: function polesZeros() {\n      return getPZ();\n    },\n    reinit: function reinit() {\n      for (cnt = 0; cnt < cf.length; cnt++) {\n        cf[cnt].z = [0, 0];\n      }\n    }\n  };\n  return self;\n};\n\nmodule.exports = IirFilter;\n\n},{\"./utils\":9}],8:[function(require,module,exports){\n'use strict';\n\n/**\n * Test filter\n */\nvar TestFilter = function TestFilter(filter) {\n  var f = filter;\n\n  var simData = [];\n  var cnt;\n\n  var randomValues = function randomValues(params) {\n    for (cnt = 0; cnt < params.steps; cnt++) {\n      simData.push(f.singleStep((Math.random() - 0.5) * params.pp + params.offset));\n    }\n  };\n\n  var stepValues = function stepValues(params) {\n    var max = params.offset + params.pp;\n    var min = params.offset - params.pp;\n    for (cnt = 0; cnt < params.steps; cnt++) {\n      if (cnt % 200 < 100) {\n        simData.push(f.singleStep(max));\n      } else {\n        simData.push(f.singleStep(min));\n      }\n    }\n  };\n\n  var impulseValues = function impulseValues(params) {\n    var max = params.offset + params.pp;\n    var min = params.offset - params.pp;\n    for (cnt = 0; cnt < params.steps; cnt++) {\n      if (cnt % 100 === 0) {\n        simData.push(f.singleStep(max));\n      } else {\n        simData.push(f.singleStep(min));\n      }\n    }\n  };\n\n  var rampValues = function rampValues(params) {\n    var max = params.offset + params.pp;\n    var min = params.offset - params.pp;\n    var val = min;\n    var diff = (max - min) / 100;\n    for (cnt = 0; cnt < params.steps; cnt++) {\n      if (cnt % 200 < 100) {\n        val += diff;\n      } else {\n        val -= diff;\n      }\n      simData.push(f.singleStep(val));\n    }\n  };\n\n  var self = {\n    randomStability: function randomStability(params) {\n      f.reinit();\n      simData.length = 0;\n      randomValues(params);\n      for (cnt = params.setup; cnt < simData.length; cnt++) {\n        if (simData[cnt] > params.maxStable || simData[cnt] < params.minStable) {\n          return simData[cnt];\n        }\n      }\n      return true;\n    },\n    directedRandomStability: function directedRandomStability(params) {\n      f.reinit();\n      simData.length = 0;\n      var i;\n      for (i = 0; i < params.tests; i++) {\n        var choose = Math.random();\n        if (choose < 0.25) {\n          randomValues(params);\n        } else if (choose < 0.5) {\n          stepValues(params);\n        } else if (choose < 0.75) {\n          impulseValues(params);\n        } else {\n          rampValues(params);\n        }\n      }\n      randomValues(params);\n      for (cnt = params.setup; cnt < simData.length; cnt++) {\n        if (simData[cnt] > params.maxStable || simData[cnt] < params.minStable) {\n          return simData[cnt];\n        }\n      }\n      return true;\n    },\n    evaluateBehavior: function evaluateBehavior() {}\n  };\n  return self;\n};\n\nmodule.exports = TestFilter;\n\n},{}],9:[function(require,module,exports){\n'use strict';\n\n/**\n * Evaluate phase\n */\nexports.evaluatePhase = function (res) {\n  var xcnt = 0;\n  var cnt = 0;\n  var pi = Math.PI;\n  var tpi = 2 * pi;\n  var phase = [];\n  for (cnt = 0; cnt < res.length; cnt++) {\n    phase.push(res[cnt].phase);\n  }\n  res[0].unwrappedPhase = res[0].phase;\n  res[0].groupDelay = 0;\n  // TODO: more sophisticated phase unwrapping needed\n  for (cnt = 1; cnt < phase.length; cnt++) {\n    var diff = phase[cnt] - phase[cnt - 1];\n    if (diff > pi) {\n      for (xcnt = cnt; xcnt < phase.length; xcnt++) {\n        phase[xcnt] -= tpi;\n      }\n    } else if (diff < -pi) {\n      for (xcnt = cnt; xcnt < phase.length; xcnt++) {\n        phase[xcnt] += tpi;\n      }\n    }\n    if (phase[cnt] < 0) {\n      res[cnt].unwrappedPhase = -phase[cnt];\n    } else {\n      res[cnt].unwrappedPhase = phase[cnt];\n    }\n\n    res[cnt].phaseDelay = res[cnt].unwrappedPhase / (cnt / res.length);\n    res[cnt].groupDelay = (res[cnt].unwrappedPhase - res[cnt - 1].unwrappedPhase) / (pi / res.length);\n    if (res[cnt].groupDelay < 0) {\n      res[cnt].groupDelay = -res[cnt].groupDelay;\n    }\n  }\n  if (res[0].magnitude !== 0) {\n    res[0].phaseDelay = res[1].phaseDelay;\n    res[0].groupDelay = res[1].groupDelay;\n  } else {\n    res[0].phaseDelay = res[2].phaseDelay;\n    res[0].groupDelay = res[2].groupDelay;\n    res[1].phaseDelay = res[2].phaseDelay;\n    res[1].groupDelay = res[2].groupDelay;\n  }\n};\n\n/**\n * Run multi filter\n */\nexports.runMultiFilter = function (input, d, doStep, overwrite) {\n  var out = [];\n  if (overwrite) {\n    out = input;\n  }\n  var i;\n  for (i = 0; i < input.length; i++) {\n    out[i] = doStep(input[i], d);\n  }\n  return out;\n};\n\nexports.runMultiFilterReverse = function (input, d, doStep, overwrite) {\n  var out = [];\n  if (overwrite) {\n    out = input;\n  }\n  var i;\n  for (i = input.length - 1; i >= 0; i--) {\n    out[i] = doStep(input[i], d);\n  }\n  return out;\n};\n\nvar factorial = function factorial(_x, _x2) {\n  var _again = true;\n\n  _function: while (_again) {\n    var n = _x,\n        a = _x2;\n    _again = false;\n\n    if (!a) {\n      a = 1;\n    }\n    if (n !== Math.floor(n) || a !== Math.floor(a)) {\n      return 1;\n    }\n    if (n === 0 || n === 1) {\n      return a;\n    } else {\n      _x = n - 1;\n      _x2 = a * n;\n      _again = true;\n      continue _function;\n    }\n  }\n};\n\n/**\n * Bessel factors\n */\nexports.besselFactors = function (n) {\n  var res = [];\n  for (var k = 0; k < n + 1; k++) {\n    var p = factorial(2 * n - k);\n    var q = Math.pow(2, n - k) * factorial(k) * factorial(n - k);\n    res.unshift(Math.floor(p / q));\n  }\n  return res;\n};\n\nvar fractionToFp = function fractionToFp(fraction, fractionBits) {\n  var fpFraction = 0;\n  for (var cnt = 0; cnt < fractionBits; cnt++) {\n    var bitVal = 1 / Math.pow(2, cnt + 1);\n    if (fraction > bitVal) {\n      fraction -= bitVal;\n      fpFraction += bitVal;\n    }\n  }\n  return fpFraction;\n};\n\nvar numberToFp = function numberToFp(number, numberBits) {\n  return number & Math.pow(2, numberBits);\n};\n\nvar valueToFp = function valueToFp(value, numberBits, fractionBits) {\n  var number = Math.abs(value);\n  var fraction = value - number;\n  var fpNumber = {\n    number: numberToFp(number, numberBits).toString(),\n    fraction: fractionToFp(fraction, fractionBits).toString(),\n    numberBits: numberBits,\n    fractionBits: fractionBits\n  };\n  return fpNumber;\n};\n\nexports.fixedPoint = {\n  convert: function convert(value, numberBits, fractionBits) {\n    return valueToFp(value, numberBits, fractionBits);\n  },\n  add: function add(fpVal1, fpVal2) {},\n  sub: function sub(fpVal1, fpVal2) {},\n  mul: function mul(fpVal1, fpVal2) {},\n  div: function div(fpVal1, fpVal2) {}\n};\n\n/**\n * Complex\n */\nexports.complex = {\n\n  div: function div(p, q) {\n    var a = p.re;\n    var b = p.im;\n    var c = q.re;\n    var d = q.im;\n    var n = c * c + d * d;\n    var x = {\n      re: (a * c + b * d) / n,\n      im: (b * c - a * d) / n\n    };\n    return x;\n  },\n  mul: function mul(p, q) {\n    var a = p.re;\n    var b = p.im;\n    var c = q.re;\n    var d = q.im;\n    var x = {\n      re: a * c - b * d,\n      im: (a + b) * (c + d) - a * c - b * d\n    };\n    return x;\n  },\n  add: function add(p, q) {\n    var x = {\n      re: p.re + q.re,\n      im: p.im + q.im\n    };\n    return x;\n  },\n  sub: function sub(p, q) {\n    var x = {\n      re: p.re - q.re,\n      im: p.im - q.im\n    };\n    return x;\n  },\n  phase: function phase(n) {\n    return Math.atan2(n.im, n.re);\n  },\n  magnitude: function magnitude(n) {\n    return Math.sqrt(n.re * n.re + n.im * n.im);\n  }\n};\n\n},{}]},{},[1])(1)\n});\n",["143","144"],"C:\\Users\\Thomas\\grain\\src\\Animator.js",[],"C:\\Users\\Thomas\\grain\\src\\useWindowSize.js",[],{"ruleId":"145","replacedBy":"146"},{"ruleId":"147","replacedBy":"148"},{"ruleId":"145","replacedBy":"149"},{"ruleId":"147","replacedBy":"150"},{"ruleId":"151","severity":1,"message":"152","line":80,"column":8,"nodeType":"153","messageId":"154","endLine":80,"endColumn":21},{"ruleId":"151","severity":1,"message":"155","line":82,"column":8,"nodeType":"153","messageId":"154","endLine":82,"endColumn":11},{"ruleId":"151","severity":1,"message":"156","line":83,"column":9,"nodeType":"153","messageId":"154","endLine":83,"endColumn":11},{"ruleId":"151","severity":1,"message":"157","line":83,"column":13,"nodeType":"153","messageId":"154","endLine":83,"endColumn":16},{"ruleId":"151","severity":1,"message":"158","line":83,"column":23,"nodeType":"153","messageId":"154","endLine":83,"endColumn":26},{"ruleId":"151","severity":1,"message":"159","line":83,"column":28,"nodeType":"153","messageId":"154","endLine":83,"endColumn":31},{"ruleId":"151","severity":1,"message":"160","line":84,"column":8,"nodeType":"153","messageId":"154","endLine":84,"endColumn":13},{"ruleId":"151","severity":1,"message":"161","line":106,"column":9,"nodeType":"153","messageId":"154","endLine":106,"endColumn":18},{"ruleId":"151","severity":1,"message":"162","line":107,"column":9,"nodeType":"153","messageId":"154","endLine":107,"endColumn":18},{"ruleId":"151","severity":1,"message":"163","line":108,"column":9,"nodeType":"153","messageId":"154","endLine":108,"endColumn":18},{"ruleId":"151","severity":1,"message":"164","line":109,"column":9,"nodeType":"153","messageId":"154","endLine":109,"endColumn":18},{"ruleId":"151","severity":1,"message":"165","line":113,"column":10,"nodeType":"153","messageId":"154","endLine":113,"endColumn":21},{"ruleId":"151","severity":1,"message":"166","line":113,"column":23,"nodeType":"153","messageId":"154","endLine":113,"endColumn":37},{"ruleId":"151","severity":1,"message":"167","line":115,"column":18,"nodeType":"153","messageId":"154","endLine":115,"endColumn":27},{"ruleId":"168","severity":1,"message":"169","line":139,"column":6,"nodeType":"170","endLine":139,"endColumn":8,"suggestions":"171"},{"ruleId":"168","severity":1,"message":"172","line":142,"column":3,"nodeType":"153","endLine":142,"endColumn":12,"suggestions":"173"},{"ruleId":"174","severity":1,"message":"175","line":181,"column":18,"nodeType":"176","messageId":"177","endLine":181,"endColumn":20},{"ruleId":"174","severity":1,"message":"175","line":190,"column":18,"nodeType":"176","messageId":"177","endLine":190,"endColumn":20},{"ruleId":"178","severity":1,"message":"179","line":244,"column":14,"nodeType":"153","messageId":"180","endLine":244,"endColumn":15},{"ruleId":"178","severity":1,"message":"179","line":263,"column":14,"nodeType":"153","messageId":"180","endLine":263,"endColumn":15},{"ruleId":"151","severity":1,"message":"181","line":12,"column":31,"nodeType":"153","messageId":"154","endLine":12,"endColumn":53},{"ruleId":"151","severity":1,"message":"182","line":33,"column":9,"nodeType":"153","messageId":"154","endLine":33,"endColumn":23},{"ruleId":"151","severity":1,"message":"183","line":40,"column":9,"nodeType":"153","messageId":"154","endLine":40,"endColumn":24},{"ruleId":"151","severity":1,"message":"184","line":3,"column":17,"nodeType":"153","messageId":"154","endLine":3,"endColumn":26},{"ruleId":"185","severity":1,"message":"186","line":2,"column":5,"nodeType":"187","messageId":"188","endLine":2,"endColumn":18,"fix":"189"},{"ruleId":"174","severity":1,"message":"175","line":15,"column":11,"nodeType":"176","messageId":"177","endLine":15,"endColumn":13},{"ruleId":"145","replacedBy":"190"},{"ruleId":"147","replacedBy":"191"},{"ruleId":"185","severity":1,"message":"186","line":23,"column":2,"nodeType":"187","messageId":"188","endLine":23,"endColumn":15,"fix":"192"},{"ruleId":"151","severity":1,"message":"184","line":3,"column":17,"nodeType":"153","messageId":"154","endLine":3,"endColumn":26},{"ruleId":"145","replacedBy":"193"},{"ruleId":"147","replacedBy":"194"},{"ruleId":"195","severity":2,"message":"196","line":7,"column":128,"nodeType":"153","messageId":"197","endLine":7,"endColumn":134},{"ruleId":"195","severity":2,"message":"196","line":7,"column":140,"nodeType":"153","messageId":"197","endLine":7,"endColumn":146},{"ruleId":"198","severity":2,"message":"199","line":7,"column":266,"nodeType":"153","messageId":"200","endLine":7,"endColumn":270},{"ruleId":"198","severity":2,"message":"199","line":7,"column":288,"nodeType":"153","messageId":"200","endLine":7,"endColumn":292},{"ruleId":"151","severity":1,"message":"201","line":7,"column":336,"nodeType":"153","messageId":"154","endLine":7,"endColumn":342},{"ruleId":"151","severity":1,"message":"202","line":7,"column":343,"nodeType":"153","messageId":"154","endLine":7,"endColumn":349},{"ruleId":"151","severity":1,"message":"203","line":7,"column":350,"nodeType":"153","messageId":"154","endLine":7,"endColumn":357},{"ruleId":"204","severity":1,"message":"205","line":7,"column":583,"nodeType":"206","messageId":"207","endLine":7,"endColumn":584},{"ruleId":"185","severity":1,"message":"186","line":8,"column":1,"nodeType":"187","messageId":"188","endLine":8,"endColumn":14,"fix":"208"},{"ruleId":"185","severity":1,"message":"186","line":23,"column":1,"nodeType":"187","messageId":"188","endLine":23,"endColumn":14,"fix":"209"},{"ruleId":"185","severity":1,"message":"186","line":151,"column":1,"nodeType":"187","messageId":"188","endLine":151,"endColumn":14,"fix":"210"},{"ruleId":"211","severity":1,"message":"212","line":179,"column":8,"nodeType":"153","messageId":"213","endLine":179,"endColumn":9},{"ruleId":"211","severity":1,"message":"212","line":179,"column":33,"nodeType":"153","messageId":"213","endLine":179,"endColumn":34},{"ruleId":"211","severity":1,"message":"212","line":180,"column":18,"nodeType":"153","messageId":"213","endLine":180,"endColumn":19},{"ruleId":"211","severity":1,"message":"212","line":180,"column":39,"nodeType":"153","messageId":"213","endLine":180,"endColumn":40},{"ruleId":"211","severity":1,"message":"212","line":181,"column":18,"nodeType":"153","messageId":"213","endLine":181,"endColumn":19},{"ruleId":"211","severity":1,"message":"212","line":181,"column":39,"nodeType":"153","messageId":"213","endLine":181,"endColumn":40},{"ruleId":"185","severity":1,"message":"186","line":646,"column":1,"nodeType":"187","messageId":"188","endLine":646,"endColumn":14,"fix":"214"},{"ruleId":"185","severity":1,"message":"186","line":784,"column":1,"nodeType":"187","messageId":"188","endLine":784,"endColumn":14,"fix":"215"},{"ruleId":"185","severity":1,"message":"186","line":903,"column":1,"nodeType":"187","messageId":"188","endLine":903,"endColumn":14,"fix":"216"},{"ruleId":"185","severity":1,"message":"186","line":1187,"column":1,"nodeType":"187","messageId":"188","endLine":1187,"endColumn":14,"fix":"217"},{"ruleId":"185","severity":1,"message":"186","line":1457,"column":1,"nodeType":"187","messageId":"188","endLine":1457,"endColumn":14,"fix":"218"},{"ruleId":"185","severity":1,"message":"186","line":1557,"column":1,"nodeType":"187","messageId":"188","endLine":1557,"endColumn":14,"fix":"219"},{"ruleId":"220","severity":1,"message":"221","line":1655,"column":16,"nodeType":"153","messageId":"177","endLine":1655,"endColumn":25,"fix":"222"},{"ruleId":"145","replacedBy":"223"},{"ruleId":"147","replacedBy":"224"},"no-native-reassign",["225"],"no-negated-in-lhs",["226"],["225"],["226"],"no-unused-vars","'useWindowSize' is defined but never used.","Identifier","unusedVar","'LPF' is defined but never used.","'ma' is defined but never used.","'dma' is defined but never used.","'sma' is defined but never used.","'wma' is defined but never used.","'image' is defined but never used.","'defaultX1' is assigned a value but never used.","'defaultY1' is assigned a value but never used.","'defaultX2' is assigned a value but never used.","'defaultY2' is assigned a value but never used.","'graphHeight' is assigned a value but never used.","'setGraphHeight' is assigned a value but never used.","'setSmooth' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'drawingCanvasHeight' and 'drawingCanvasWidth'. Either include them or remove the dependency array.","ArrayExpression",["227"],"React Hook useEffect contains a call to 'setX1'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass [plotLine, x1p, frameWidth, bildetHeight, y1p, x2p, y2p] as a second argument to the useEffect Hook.",["228"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-redeclare","'i' is already defined.","redeclared","'setEndpointStrokeWidth' is assigned a value but never used.","'circleDivStyle' is assigned a value but never used.","'circleStyleDark' is assigned a value but never used.","'useEffect' is defined but never used.","strict","'use strict' is unnecessary inside of modules.","ExpressionStatement","module",{"range":"229","text":"230"},["225"],["226"],{"range":"231","text":"230"},["225"],["226"],"no-undef","'define' is not defined.","undef","no-restricted-globals","Unexpected use of 'self'.","defaultMessage","'define' is defined but never used.","'module' is defined but never used.","'exports' is defined but never used.","no-sequences","Unexpected use of comma operator.","SequenceExpression","unexpectedCommaExpression",{"range":"232","text":"230"},{"range":"233","text":"230"},{"range":"234","text":"230"},"no-use-before-define","'i' was used before it was defined.","usedBeforeDefined",{"range":"235","text":"230"},{"range":"236","text":"230"},{"range":"237","text":"230"},{"range":"238","text":"230"},{"range":"239","text":"230"},{"range":"240","text":"230"},"no-extra-label","This label '_function' is unnecessary.",{"range":"241","text":"230"},["225"],["226"],"no-global-assign","no-unsafe-negation",{"desc":"242","fix":"243"},{"desc":"244","fix":"245"},[63,76],"",[1026,1039],[953,966],[1455,1468],[9733,9746],[23558,23571],[27096,27109],[30011,30024],[38978,38991],[45558,45571],[48148,48161],[50440,50450],"Update the dependencies array to be: [drawingCanvasHeight, drawingCanvasWidth]",{"range":"246","text":"247"},"Add dependencies array: [plotLine, x1p, frameWidth, bildetHeight, y1p, x2p, y2p]",{"range":"248","text":"249"},[5546,5548],"[drawingCanvasHeight, drawingCanvasWidth]",[6023,6023],", [plotLine, x1p, frameWidth, bildetHeight, y1p, x2p, y2p]"]