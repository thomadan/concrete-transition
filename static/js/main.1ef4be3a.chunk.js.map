{"version":3,"sources":["curve.js","LPF.js","images/stones.jpg","Indicator.js","Bildet.js","Graph.js","Animator.js","useWindowSize.js","Frame.js","App.js","registerServiceWorker.js","index.js"],"names":["CanvasRenderingContext2D","prototype","curve","points","tension","numOfSeg","close","pts","i","l","length","rPos","res","Float32Array","cache","cachePtr","slice","unshift","push","st","st2","st3","st23","st32","parse","t","pt1","pt2","pt3","pt4","t1x","t1y","t2x","t2y","c","c1","c2","c3","c4","this","lineTo","LPF","smoothing","buffer","bufferMaxSize","init","values","__push","value","removed","shift","next","nextValue","self","result","reduce","last","current","smoothArray","Math","round","module","exports","Indicator","props","useState","endpointStrokeWidth","circleStyle","stroke","opacity","fill","strokeWidth","svgteststyle","transform","top","preserveAspectRatio","useEffect","console","log","x1","y1","id","style","position","width","height","x2","y2","axis","handle","x","y","scale","onDrag","e","ui","xyChange","className","viewBox","cx","cy","r","Bildet","ctx","document","getElementById","getContext","clearRect","fillStyle","fillRect","imageObj","Image","src","image","onload","drawImage","strokeStyle","lineWidth","moveTo","initCanvas","ref","passRef","frameWidth","bildetHeight","Graph","drawingCanvasWidth","drawingCanvasHeight","Animator","onClick","animate","useWindowSize","Frame","setFrameWidth","setBildetHeight","setDrawingCanvasWidth","setDrawingCanvasHeight","imageCanvasRef","useRef","drawingCanvasRef","setX1","setY1","setX2","setY2","x1p","setX1p","y1p","setY1p","x2p","setX2p","y2p","setY2p","smooth","numberOfPoints","setCalibratePoint","handleResize","getBoundingClientRect","plotLine","imageCtx","drawCtx","lineCap","beginPath","lx1","ly1","lx2","ly2","firstColorPoint","getImageData","data","lastColorPoint","ema","splice","filter","initx","inity","window","addEventListener","setTimeout","handleID","xgot","ygot","visibility","myVar","setInterval","valueAtZero","direction","clearInterval","App","isLocalhost","Boolean","location","hostname","match","registerValidSW","swUrl","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","catch","error","ReactDOM","render","URL","process","origin","fetch","response","status","headers","get","indexOf","ready","unregister","reload","checkValidServiceWorker","registerServiceWorker"],"mappings":";kOAoBAA,yBAAyBC,UAAUC,MAAQF,yBAAyBC,UAAUC,OAAS,SAASC,EAAQC,EAASC,EAAUC,GAE1H,aAGAF,EAA8B,kBAAZA,EAAwBA,EAAU,GACpDC,EAAWA,GAAsB,GAEjC,IAAIE,EACHC,EAAI,EACJC,EAAIN,EAAOO,OACXC,EAAO,EAEPC,EAAM,IAAIC,cADFJ,EAAE,GAAKJ,EAAW,GAAKC,EAAQ,EAAID,EAAU,IAErDS,EAAQ,IAAID,aAA8B,GAAhBR,EAAW,IACrCU,EAAW,EAkBZ,IAhBAR,EAAMJ,EAAOa,MAAM,GAEfV,GACHC,EAAIU,QAAQd,EAAOM,EAAI,IACvBF,EAAIU,QAAQd,EAAOM,EAAI,IACvBF,EAAIW,KAAKf,EAAO,GAAIA,EAAO,MAG3BI,EAAIU,QAAQd,EAAO,IACnBI,EAAIU,QAAQd,EAAO,IACnBI,EAAIW,KAAKf,EAAOM,EAAI,GAAIN,EAAOM,EAAI,KAIpCK,EAAM,GAAK,EAEJN,EAAIH,EAAUG,IAAK,CAEzB,IAAIW,EAAKX,EAAIH,EACZe,EAAMD,EAAKA,EACXE,EAAMD,EAAMD,EACZG,EAAa,EAAND,EACPE,EAAa,EAANH,EAERN,EAAMC,KAAcO,EAAOC,EAAO,EAClCT,EAAMC,KAAcQ,EAAOD,EAC3BR,EAAMC,KAAcM,EAAM,EAAID,EAAMD,EACpCL,EAAMC,KAAcM,EAAMD,EAgB3B,SAASI,EAAMjB,EAAKO,EAAOL,GAE1B,IAAK,IAAWgB,EAAPjB,EAAI,EAAMA,EAAIC,EAAGD,GAAK,EAAG,CAEjC,IAAIkB,EAAMnB,EAAIC,GACbmB,EAAMpB,EAAIC,EAAE,GACZoB,EAAMrB,EAAIC,EAAE,GACZqB,EAAMtB,EAAIC,EAAE,GAEZsB,GAAOF,EAAMrB,EAAIC,EAAE,IAAMJ,EACzB2B,GAAOF,EAAMtB,EAAIC,EAAE,IAAMJ,EACzB4B,GAAOzB,EAAIC,EAAE,GAAKkB,GAAOtB,EACzB6B,GAAO1B,EAAIC,EAAE,GAAKmB,GAAOvB,EAE1B,IAAKqB,EAAI,EAAGA,EAAIpB,EAAUoB,IAAK,CAE9B,IAAIS,EAAIT,GAAK,EAEZU,EAAKrB,EAAMoB,GACXE,EAAKtB,EAAMoB,EAAE,GACbG,EAAKvB,EAAMoB,EAAE,GACbI,EAAKxB,EAAMoB,EAAE,GAEdtB,EAAID,KAAUwB,EAAKT,EAAMU,EAAKR,EAAMS,EAAKP,EAAMQ,EAAKN,EACpDpB,EAAID,KAAUwB,EAAKR,EAAMS,EAAKP,EAAMQ,EAAKN,EAAMO,EAAKL,IAWvD,IAhDAnB,IAAQC,GAAY,EAGpBS,EAAMjB,EAAKO,EAAOL,GAEdH,KAEHC,EAAM,IACFW,KAAKf,EAAOM,EAAI,GAAIN,EAAOM,EAAI,GAAIN,EAAOM,EAAI,GAAIN,EAAOM,EAAI,IACjEF,EAAIW,KAAKf,EAAO,GAAIA,EAAO,GAAIA,EAAO,GAAIA,EAAO,IACjDqB,EAAMjB,EAAKO,EAAO,IAiCnBL,EAAIH,EAAQ,EAAIH,EAAOO,OAAS,EAChCE,EAAID,KAAUR,EAAOM,GACrBG,EAAID,GAAQR,EAAOM,EAAE,GAGjBD,EAAI,EAAGC,EAAIG,EAAIF,OAAQF,EAAIC,EAAGD,GAAK,EACtC+B,KAAKC,OAAO5B,EAAIJ,GAAII,EAAIJ,EAAE,IAE3B,OAAOI,I,cC/GR,IAAI6B,EAAM,SAASC,GACfH,KAAKG,UAAYA,GAAa,GAC9BH,KAAKI,OAAS,GACdJ,KAAKK,cAAgB,IAGzBH,EAAIxC,UAAY,CASZ4C,KAAM,SAASC,GACX,IAAK,IAAItC,EAAI,EAAGA,EAAIsC,EAAOpC,OAAQF,IAC/B+B,KAAKQ,OAAOD,EAAOtC,IAEvB,OAAO+B,KAAKI,QAUhBI,OAAQ,SAASC,GACb,IAAIC,EAAWV,KAAKI,OAAOjC,SAAW6B,KAAKK,cACrCL,KAAKI,OAAOO,QACZ,EAGN,OADAX,KAAKI,OAAOzB,KAAK8B,GACVC,GAUXE,KAAM,SAAUC,GACZ,IAAIC,EAAOd,KAEPU,EAAUV,KAAKQ,OAAOK,GAEtBE,EAASf,KAAKI,OAAOY,QAAO,SAASC,EAAMC,GAC3C,OAAOJ,EAAKX,UAAYe,GAAW,EAAIJ,EAAKX,WAAac,IAC1DP,GAGH,OADAV,KAAKI,OAAOJ,KAAKI,OAAOjC,OAAS,GAAK4C,EAC/BA,GAUXI,YAAa,SAAUZ,GAEnB,IADA,IAAIE,EAAQF,EAAO,GACVtC,EAAI,EAAGA,EAAIsC,EAAOpC,OAAQF,IAAI,CAEnCwC,IADmBF,EAAOtC,GACDwC,GAAST,KAAKG,UACvCI,EAAOtC,GAAKmD,KAAKC,MAAMZ,GAE3B,OAAOF,IAIfe,EAAOC,QAAU,IAAIrB,G,2FCnFN,G,MAAA,IAA0B,oC,sBCqJ1BsB,MA5If,SAAoBC,GAAQ,IAAD,EAE6BC,mBAAS,UAFtC,mBAElBC,EAFkB,KAqCnBC,GArCmB,KAqCL,CAClBC,OAAQ,UACRC,QAAS,MACTC,KAAM,OACNC,YAAaL,IAGTM,EAAe,CACnBC,UAAW,4BACXC,IAAK,OAELC,oBAAqB,QAuBvB,OAfAC,qBAAU,WACNC,QAAQC,IAAI,iCAAmCd,EAAMe,GAAK,KAAOf,EAAMgB,OAmBzE,cAHA,CAGA,OAAKC,GAAG,YAAYC,MAvEI,CACxBC,SAAU,WAGVC,MAAO,OACPC,OAAQ,QAkER,UAGE,qBAAKH,MA5BY,CACnBC,SAAU,YA2BkBC,MAAM,OAAOC,OAAO,OAA9C,SACE,sBAAMJ,GAAG,OACHC,MAjEM,CAChBC,SAAU,WACVf,OAAQ,UACRG,YAAa,QACbF,QAAS,OA8DCU,GAAIf,EAAMe,GAAK,EACfC,GAAIhB,EAAMgB,GAAK,EACfM,GAAItB,EAAMsB,GAAK,EACfC,GAAIvB,EAAMuB,GAAK,MAIvB,cAAC,IAAD,CACEN,GAAG,aACHO,KAAK,OACLC,OAAO,UACPN,SAAU,CAACO,EAAG1B,EAAMe,GAAIY,EAAG3B,EAAMgB,IACjCY,MAAO,EACPC,OAlCN,SAAsBC,EAAGC,GACvB/B,EAAMgC,SAAS,EAAGD,EAAGL,EAAGK,EAAGJ,IA2BzB,SAUE,qBAAKV,GAAG,UAAR,SAEE,qBAAKC,MAAOV,EACVyB,UAAU,SACVb,MAAM,MACNC,OAAO,MACPa,QAAQ,gBAJV,SAME,wBAAQhB,MAAOf,EAAagC,GAAI,MAAOC,GAAI,MAAOC,EAAG,aAM3D,cAAC,IAAD,CACEpB,GAAG,aACHO,KAAK,OACLC,OAAO,UACPN,SAAU,CAACO,EAAG1B,EAAMsB,GAAIK,EAAG3B,EAAMuB,IACjCK,MAAO,EACPC,OArDN,SAAsBC,EAAGC,GACvB/B,EAAMgC,SAAS,EAAGD,EAAGL,EAAGK,EAAGJ,IA8CzB,SASE,qBAAKV,GAAG,UAAR,SAEE,qBAAKC,MAAOV,EACVyB,UAAU,SACVb,MAAM,MACNC,OAAO,MACPa,QAAQ,cAJV,SAME,wBAAQhB,MAAOf,EAAagC,GAAI,KAAMC,GAAI,KAAMC,EAAG,iB,MCjEhDC,MApDf,SAAiBtC,GAqCf,OA9BAY,qBAAU,YAMV,WACE,IACI2B,EADYC,SAASC,eAAe,aACpBC,WAAW,MAE/BH,EAAII,UAAU,EAAG,EAAG,IAAK,KACzBJ,EAAIK,UAAY,UAChBL,EAAIM,SAAS,EAAG,EAAG,KAAM,KAEzB,IAAIC,EAAW,IAAIC,MACnBD,EAASE,IAAMC,EACfH,EAASI,OAAS,WAGhBX,EAAIY,UAAUL,EAAU,EAAG,EAAG,KAAM,IAAK,EAAG,EAAG,KAAM,MAIvDP,EAAIa,YAAc,UAClBb,EAAIc,UAAY,EAChBd,EAAIe,OAAO,GAAI,KACff,EAAI/D,OAAO,GAAI,KACf+D,EAAInC,SAxBJmD,KACC,IA2BD,sBAAKtC,GAAG,SAAR,UACE,wBAAQuC,IAAKxD,EAAMyD,QAASxC,GAAG,YAAYG,MAAO,OAAQC,OAAO,QACjE,cAAC,EAAD,CACEqC,WAAY1D,EAAM0D,WAClBC,aAAc3D,EAAM2D,aACpB5C,GAAIf,EAAMe,GACVC,GAAIhB,EAAMgB,GACVM,GAAItB,EAAMsB,GACVC,GAAIvB,EAAMuB,GACVS,SAAUhC,EAAMgC,e,MCnDT4B,MAXf,SAAgB5D,GACd,OACE,sBAAKiC,UAAU,QAAf,cACE,wBAAQuB,IAAKxD,EAAMyD,QAASxC,GAAG,gBAAgBG,MAAOpB,EAAM6D,mBAAoBxC,OAAQrB,EAAM8D,sBAC9F,qBAAK7C,GAAG,gBAAgBiB,QAAQ,cAAcvB,oBAAoB,OAAlE,SACE,sBAAMM,GAAG,OAAOF,GAAG,KAAKC,GAAG,IAAIM,GAAG,KAAKC,GAAG,c,MCenCwC,MAXf,SAAmB/D,GAEjB,OACE,qBAAKiB,GAAG,MAAMgB,UAAU,WAAxB,SACE,qBAAK+B,QAAShE,EAAMiE,QAAShD,GAAG,eAAeiB,QAAQ,aAAvD,SACE,yBAAS/F,OAAO,yB,YCgBT+H,I,OCkQAC,MAlRf,WAAkB,IAAD,EAEqBlE,mBAAS,KAF9B,mBAERyD,EAFQ,KAEIU,EAFJ,OAGyBnE,mBAAS,KAHlC,mBAGR0D,EAHQ,KAGMU,EAHN,OAIqCpE,mBAAS,MAJ9C,mBAIR4D,EAJQ,KAIYS,EAJZ,OAKuCrE,mBAAS,MALhD,mBAKR6D,EALQ,KAKaS,EALb,OAMuBtE,mBAAS,MANhC,mBASTuE,GATS,UASQC,iBAAO,OACxBC,EAAmBD,iBAAO,MAVjB,EAaKxE,mBAAS,KAbd,mBAaRc,EAbQ,KAaJ4D,EAbI,OAcK1E,mBAAS,KAdd,mBAcRe,EAdQ,KAcJ4D,EAdI,OAeK3E,mBAAS,KAfd,mBAeRqB,EAfQ,KAeJuD,EAfI,OAgBK5E,mBAAS,KAhBd,mBAgBRsB,EAhBQ,KAgBJuD,EAhBI,OAkBO7E,mBAAS,KAlBhB,mBAkBR8E,EAlBQ,KAkBHC,EAlBG,OAmBO/E,mBAAS,IAnBhB,mBAmBRgF,EAnBQ,KAmBHC,EAnBG,OAoBOjF,mBAAS,IApBhB,mBAoBRkF,EApBQ,KAoBHC,GApBG,QAqBOnF,mBAAS,IArBhB,qBAqBRoF,GArBQ,MAqBHC,GArBG,SA4BarF,mBAAS,GA5BtB,qBA4BRsF,GA5BQ,MA+BTC,IA/BS,MA+BQ,KA/BR,GAgC6BvF,mBAAS,GAhCtC,qBAgCQwF,IAhCR,aAmCXtJ,GAAS,GAqFb,SAASuJ,KAEPtB,EAAc5B,SAASC,eAAe,SAASkD,wBAAwBvE,OACvEiD,EAAgB7B,SAASC,eAAe,UAAUkD,wBAAwBtE,QAM5E,SAASuE,KACP/E,QAAQC,IAAI,QAGZ,IAAM+E,EAAWrB,EAAe/E,QAAQiD,WAAW,MAC7CoD,EAAUpB,EAAiBjF,QAAQiD,WAAW,MAEpDoD,EAAQnD,UAAU,EAAG,EAAGkB,EAAoBC,GAC5CgC,EAAQ1C,YAAc,UACtB0C,EAAQzC,UAAY,EACpByC,EAAQC,QAAU,QAClBD,EAAQE,YAgBR,IAXA,IAAMC,EAAMlF,GAAM,KAAO2C,GACnBwC,EAAMlF,GAAM,KAAO0C,GACnByC,EAAM7E,GAAM,KAAOoC,GACnB0C,EAAM7E,GAAM,KAAOmC,GAEnB2C,EAAkB,IAAMR,EAASS,aAAaL,EAAKC,EAAK,EAAG,GAAGK,KAAK,GACnEC,EAAiB,IAAMX,EAASS,aAAaH,EAAKC,EAAK,EAAG,GAAGG,KAAK,GAK/D/J,EAAE,EAAGA,EAAEgJ,GAAgBhJ,IAAK,CAGnC,IAAI+J,EAAOV,EAASS,aAAaL,GAAQE,EAAMF,GAAOT,GAAiBhJ,EAAI0J,GAAQE,EAAMF,GAAOV,GAAiBhJ,EAAI,EAAG,GAAG+J,KAG3HpK,GAAOe,KAAK,IAAMqJ,EAAK,IAIzBpK,GAoBF,SAAiBA,EAAQkK,EAAiBG,GAGxC,IAAK,IAAIhK,EAAE,EAAGA,EAAI,GAAIA,IACpBL,EAAOc,QAAQoJ,GAIjB,IAAS7J,EAAE,EAAGA,EAAI,GAAIA,IACpBL,EAAOe,KAAKsJ,GAYd,OATArK,EAASsK,YAAItK,EAAQoJ,IACrBpJ,EAASsK,YAAItK,EAAQoJ,IACrBpJ,EAASsK,YAAItK,EAAQoJ,IACrBpJ,EAASsK,YAAItK,EAAQoJ,KACrBpJ,EAASsK,YAAItK,EAAQoJ,KAGdmB,OAAO,EAAG,IAEVvK,EAzCEwK,CAAOxK,GAAQkK,EAAiBG,GAGzCV,EAAQxC,OAAO,EAAGnH,GAAO,GAAK,IAAM2H,GAGpC,IAAK,IAAItH,EAAE,EAAGA,EAAEgJ,GAAgBhJ,IAC9BsJ,EAAQtH,OAAOqF,EAAmB2B,GAAehJ,EAAGL,GAAOK,GAAK,IAAMsH,GAGxEgC,EAAQtH,OAAOqF,EAAoB1H,GAAOqJ,KAAkB,IAAM1B,GAGlEgC,EAAQ1F,SAERqF,GAAkBtJ,GAAO,IAyE3B,OAxNAyE,qBAAU,WAGR0D,EAAsB9B,SAASC,eAAe,iBAAiBkD,wBAAwBvE,OACvFmD,EAAuB/B,SAASC,eAAe,iBAAiBkD,wBAAwBtE,QA4C1F,SAAqBuF,EAAOC,GAE1B,IAAMhB,EAAWrB,EAAe/E,QAAQiD,WAAW,MAC7CoD,EAAUpB,EAAiBjF,QAAQiD,WAAW,MAEpDmD,EAASjD,UAAY,UAGrBkD,EAAQlD,UAAY,UACpBkD,EAAQjD,SAAS,EAAG,EAAG+D,EAAOC,GAE9Bf,EAAQ1C,YAAc,UACtB0C,EAAQzC,UAAY,EAvDpBE,CAAWM,EAAoBC,GAG/BgD,OAAOC,iBAAiB,SAAUrB,IAGlCA,KAuBAsB,YAAW,WAETrC,EAAMI,EAAMrB,GACZkB,EAAMjB,EAAesB,GAErBJ,EAAMnB,EAAayB,GACnBL,EAAMnB,EAAe0B,MACpB,OA1BF,IAGHzE,qBAAU,WAGRgF,KAGAjB,EAAMI,EAAMrB,GACZkB,EAAMjB,EAAesB,GAErBJ,EAAMnB,EAAayB,GACnBL,EAAMnB,EAAe0B,OA6LrB,sBAAKpE,GAAG,QAAR,UAEE,cAAC,EAAD,CACE2E,SAAUA,GACVnC,QAASe,EACTzD,GAAIA,EAAIC,GAAIA,EAAIM,GAAIA,EAAIC,GAAIA,EAC5BS,SA/JN,SAAeiF,EAAUC,EAAMC,GACb,GAAZF,IAGFjC,EAAOkC,EAAOxD,GAEdiB,EAAMjB,EAAaqB,GACnBG,EAAOiC,EAAOxD,GACdiB,EAAMlB,EAAauB,IAEL,GAAZgC,IACF7B,GAAO8B,EAAOxD,GACdmB,EAAMnB,EAAayB,GACnBG,GAAO6B,EAAOxD,GACdmB,EAAMpB,EAAa2B,MAkJjB3B,WAAYA,EACZC,aAAcA,IAChB,cAAC,EAAD,CACEF,QAASiB,EACTb,mBAAoBA,EACpBC,oBAAqBA,IACvB,cAAC,EAAD,CACEG,QA3DN,WAGEzB,SAASC,eAAe,iBAAiBvB,MAAMkG,WAAa,UAE5DvG,QAAQC,IAAI0B,SAASC,eAAe,iBAAiBvB,MAAMkG,YAI3D,IAAMC,EAAQC,aAQd,WAOE9E,SAASC,eAAe,iBAAiBvB,MAAMT,UAAY,aAAkBiD,EAAc8B,GAAkBhJ,EAAK,MAGlHgG,SAASC,eAAe,gBAAgBvB,MAAMT,UAAY,cAAiB,GAAMtE,GAAOK,GAAK,IAAQ+K,EAAc,MAAU7D,EAAa,EAAK,IAAM,MAEnI,IAAd8D,GAAkBhL,IACJ,IAAdgL,GAAkBhL,IAClBA,IAAMgJ,KAAiBgC,EAAY,IAC7B,IAAPhL,IACDgL,EAAY,EACZC,cAAcJ,GAGd7E,SAASC,eAAe,iBAAiBvB,MAAMkG,WAAa,YA5BxB,IAEpCI,EAAY,EACZhL,EAAI,EAGF+K,EAAcpL,GAAO,UCjOhBuL,MATf,WACE,OAEE,qBAAKzG,GAAG,aAAR,SACE,cAAC,EAAD,OCNA0G,EAAcC,QACW,cAA7Bd,OAAOe,SAASC,UAEe,UAA7BhB,OAAOe,SAASC,UAEhBhB,OAAOe,SAASC,SAASC,MACvB,2DA6BN,SAASC,EAAgBC,GACvBC,UAAUC,cACPC,SAASH,GACTI,MAAK,SAAAC,GACJA,EAAaC,cAAgB,WAC3B,IAAMC,EAAmBF,EAAaG,WACtCD,EAAiBE,cAAgB,WACA,cAA3BF,EAAiBG,QACfT,UAAUC,cAAcS,WAK1B/H,QAAQC,IAAI,6CAKZD,QAAQC,IAAI,4CAMrB+H,OAAM,SAAAC,GACLjI,QAAQiI,MAAM,4CAA6CA,MChEjEC,IAASC,OAAO,cAAC,EAAD,IAASxG,SAASC,eAAe,SDclC,WACb,GAA6C,kBAAmByF,UAAW,CAGzE,GADkB,IAAIe,IAAIC,uBAAwBpC,OAAOe,UAC3CsB,SAAWrC,OAAOe,SAASsB,OAIvC,OAGFrC,OAAOC,iBAAiB,QAAQ,WAC9B,IAAMkB,EAAK,UAAMiB,uBAAN,sBAENvB,EAwCX,SAAiCM,GAE/BmB,MAAMnB,GACHI,MAAK,SAAAgB,GAGkB,MAApBA,EAASC,SACuD,IAAhED,EAASE,QAAQC,IAAI,gBAAgBC,QAAQ,cAG7CvB,UAAUC,cAAcuB,MAAMrB,MAAK,SAAAC,GACjCA,EAAaqB,aAAatB,MAAK,WAC7BvB,OAAOe,SAAS+B,eAKpB5B,EAAgBC,MAGnBY,OAAM,WACLhI,QAAQC,IACN,oEAzDA+I,CAAwB5B,GAHxBD,EAAgBC,OC7BxB6B,K","file":"static/js/main.1ef4be3a.chunk.js","sourcesContent":["/*!\tCurve extension for canvas 2.3.1\r\n *\tEpistemex (c) 2013-2014\r\n *\tLicense: MIT\r\n */\r\n\r\n/**\r\n * Draws a cardinal spline through given point array. Points must be arranged\r\n * as: [x1, y1, x2, y2, ..., xn, yn]. It adds the points to the current path.\r\n *\r\n * The method continues previous path of the context. If you don't want that\r\n * then you need to use moveTo() with the first point from the input array.\r\n *\r\n * The points for the cardinal spline are returned as a new array.\r\n *\r\n * @param {Array} points - point array\r\n * @param {Number} [tension=0.5] - tension. Typically between [0.0, 1.0] but can be exceeded\r\n * @param {Number} [numOfSeg=20] - number of segments between two points (line resolution)\r\n * @param {Boolean} [close=false] - Close the ends making the line continuous\r\n * @returns {Float32Array} New array with the calculated points that was added to the path\r\n */\r\nCanvasRenderingContext2D.prototype.curve = CanvasRenderingContext2D.prototype.curve || function(points, tension, numOfSeg, close) {\r\n\r\n\t'use strict';\r\n\r\n\t// options or defaults\r\n\ttension = (typeof tension === 'number') ? tension : 0.5;\r\n\tnumOfSeg = numOfSeg ? numOfSeg : 25;\r\n\r\n\tvar pts,\t\t\t\t\t\t\t\t\t// for cloning point array\r\n\t\ti = 1,\r\n\t\tl = points.length,\r\n\t\trPos = 0,\r\n\t\trLen = (l-2) * numOfSeg + 2 + (close ? 2 * numOfSeg: 0),\r\n\t\tres = new Float32Array(rLen),\r\n\t\tcache = new Float32Array((numOfSeg + 2) * 4),\r\n\t\tcachePtr = 4;\r\n\r\n\tpts = points.slice(0);\r\n\r\n\tif (close) {\r\n\t\tpts.unshift(points[l - 1]);\t\t\t\t// insert end point as first point\r\n\t\tpts.unshift(points[l - 2]);\r\n\t\tpts.push(points[0], points[1]); \t\t// first point as last point\r\n\t}\r\n\telse {\r\n\t\tpts.unshift(points[1]);\t\t\t\t\t// copy 1. point and insert at beginning\r\n\t\tpts.unshift(points[0]);\r\n\t\tpts.push(points[l - 2], points[l - 1]);\t// duplicate end-points\r\n\t}\r\n\r\n\t// cache inner-loop calculations as they are based on t alone\r\n\tcache[0] = 1;\t\t\t\t\t\t\t\t// 1,0,0,0\r\n\r\n\tfor (; i < numOfSeg; i++) {\r\n\r\n\t\tvar st = i / numOfSeg,\r\n\t\t\tst2 = st * st,\r\n\t\t\tst3 = st2 * st,\r\n\t\t\tst23 = st3 * 2,\r\n\t\t\tst32 = st2 * 3;\r\n\r\n\t\tcache[cachePtr++] =\tst23 - st32 + 1;\t// c1\r\n\t\tcache[cachePtr++] =\tst32 - st23;\t\t// c2\r\n\t\tcache[cachePtr++] =\tst3 - 2 * st2 + st;\t// c3\r\n\t\tcache[cachePtr++] =\tst3 - st2;\t\t\t// c4\r\n\t}\r\n\r\n\tcache[++cachePtr] = 1;\t\t\t\t\t\t// 0,1,0,0\r\n\r\n\t// calc. points\r\n\tparse(pts, cache, l);\r\n\r\n\tif (close) {\r\n\t\t//l = points.length;\r\n\t\tpts = [];\r\n\t\tpts.push(points[l - 4], points[l - 3], points[l - 2], points[l - 1]); // second last and last\r\n\t\tpts.push(points[0], points[1], points[2], points[3]); // first and second\r\n\t\tparse(pts, cache, 4);\r\n\t}\r\n\r\n\tfunction parse(pts, cache, l) {\r\n\r\n\t\tfor (var i = 2, t; i < l; i += 2) {\r\n\r\n\t\t\tvar pt1 = pts[i],\r\n\t\t\t\tpt2 = pts[i+1],\r\n\t\t\t\tpt3 = pts[i+2],\r\n\t\t\t\tpt4 = pts[i+3],\r\n\r\n\t\t\t\tt1x = (pt3 - pts[i-2]) * tension,\r\n\t\t\t\tt1y = (pt4 - pts[i-1]) * tension,\r\n\t\t\t\tt2x = (pts[i+4] - pt1) * tension,\r\n\t\t\t\tt2y = (pts[i+5] - pt2) * tension;\r\n\r\n\t\t\tfor (t = 0; t < numOfSeg; t++) {\r\n\r\n\t\t\t\tvar c = t << 2, //t * 4;\r\n\r\n\t\t\t\t\tc1 = cache[c],\r\n\t\t\t\t\tc2 = cache[c+1],\r\n\t\t\t\t\tc3 = cache[c+2],\r\n\t\t\t\t\tc4 = cache[c+3];\r\n\r\n\t\t\t\tres[rPos++] = c1 * pt1 + c2 * pt3 + c3 * t1x + c4 * t2x;\r\n\t\t\t\tres[rPos++] = c1 * pt2 + c2 * pt4 + c3 * t1y + c4 * t2y;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// add last point\r\n\tl = close ? 0 : points.length - 2;\r\n\tres[rPos++] = points[l];\r\n\tres[rPos] = points[l+1];\r\n\r\n\t// add lines to path\r\n\tfor(i = 0, l = res.length; i < l; i += 2)\r\n\t\tthis.lineTo(res[i], res[i+1]);\r\n\r\n\treturn res;\r\n};","/**\r\n * LPF\r\n * Low Pass Filter for JavaScript\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\r\nvar LPF = function(smoothing) {\r\n    this.smoothing = smoothing || 0.5; // must be smaller than 1\r\n    this.buffer = []; // FIFO queue\r\n    this.bufferMaxSize = 10;\r\n};\r\n\r\nLPF.prototype = {\r\n\r\n    /**\r\n     * Init buffer with array of values\r\n     * \r\n     * @param {array} values\r\n     * @returns {array}\r\n     * @access public\r\n     */\r\n    init: function(values) {\r\n        for (var i = 0; i < values.length; i++) {\r\n            this.__push(values[i]);\r\n        }\r\n        return this.buffer;\r\n    },\r\n\r\n    /**\r\n     * Add new value to buffer (FIFO queue)\r\n     *\r\n     * @param {integer|float} value\r\n     * @returns {integer|float}\r\n     * @access private\r\n     */\r\n    __push: function(value) {\r\n        var removed = (this.buffer.length === this.bufferMaxSize)\r\n            ? this.buffer.shift()\r\n            : 0;\r\n\r\n        this.buffer.push(value);\r\n        return removed;\r\n    },\r\n\r\n    /**\r\n     * Smooth value from stream\r\n     *\r\n     * @param {integer|float} nextValue\r\n     * @returns {integer|float}\r\n     * @access public\r\n     */\r\n    next: function (nextValue) {\r\n        var self = this;\r\n        // push new value to the end, and remove oldest one\r\n        var removed = this.__push(nextValue);\r\n        // smooth value using all values from buffer\r\n        var result = this.buffer.reduce(function(last, current) {\r\n            return self.smoothing * current + (1 - self.smoothing) * last;\r\n        }, removed);\r\n        // replace smoothed value\r\n        this.buffer[this.buffer.length - 1] = result;\r\n        return result;\r\n    },\r\n\r\n    /**\r\n     * Smooth array of values\r\n     *\r\n     * @param {array} values\r\n     * @returns {undefined}\r\n     * @access public\r\n     */\r\n    smoothArray: function (values){\r\n        var value = values[0];\r\n        for (var i = 1; i < values.length; i++){\r\n            var currentValue = values[i];\r\n            value += (currentValue - value) * this.smoothing;\r\n            values[i] = Math.round(value);\r\n        }\r\n        return values;\r\n    }\r\n};\r\n\r\nmodule.exports = new LPF();","export default __webpack_public_path__ + \"static/media/stones.f3314072.jpg\";","// indicator component:\r\n//\t a line draggable by its endpoints,\r\n//   indicating what pixels from underlying image to process.\r\n//   for use in frame component\r\n\r\nimport React, { useState, useEffect } from 'react';\r\nimport Draggable from 'react-draggable';  // import react-draggable, which is installed via npm, for dragging elements\r\nimport './Indicator.css';\r\n \r\nfunction Indicator (props) {\r\n\r\n  const [endpointStrokeWidth, setEndpointStrokeWidth] = useState('0.42em');\r\n\r\n  // dynamic styles\r\n  const indicatorDivStyle = {\r\n    position: 'relative',\r\n    //backgroundColor: 'red',\r\n\r\n    width: '100%',\r\n    height: '100%',\r\n    //top: '50%',\r\n    //left: '50%',\r\n    //transform: 'translate(-50%, -50%)',\r\n  };\r\n\r\n  const lineStyle = {\r\n    position: 'absolute',\r\n    stroke: '#6b6b6b',\r\n    strokeWidth: '0.2em',\r\n    opacity: '0.7',\r\n  };\r\n\r\n  const circleDivStyle = {\r\n    display: 'inline-block',\r\n    height: '30px',\r\n    width: '30px',\r\n    zIndex: 2\r\n  };\r\n\r\n  const circleStyleDark = {\r\n    stroke: '#554444',\r\n    opacity: '0.3',\r\n    fill: 'none',\r\n    strokeWidth: endpointStrokeWidth\r\n  };\r\n\r\n  const circleStyle = {\r\n    stroke: '#554444',\r\n    opacity: '0.3',\r\n    fill: 'none',\r\n    strokeWidth: endpointStrokeWidth\r\n  };\r\n\r\n  const svgteststyle = {\r\n    transform: 'translate(-2.5em, -2.5em)',\r\n    top: '30px',\r\n    //backgroundColor: 'red',\r\n    preserveAspectRatio: \"none\",\r\n  }\r\n\r\n  const svgLineStyle = {\r\n    position: 'absolute'\r\n  }\r\n\r\n  // on every change in state\r\n  useEffect(() => {\r\n      console.log('useeffect indicator with x, y ' + props.x1 + ', ' + props.y1);\r\n\r\n  });\r\n\r\n  function handleMove5 (e, ui) {\r\n    props.xyChange(0, ui.x, ui.y);\r\n    // console.log('handle1 ui x ' + ui.x + ' ui y ' + ui.y);\r\n  }\r\n\r\n  function handleMove6 (e, ui) {\r\n    props.xyChange(1, ui.x, ui.y);\r\n    // console.log('handle2 ui x ' + ui.x + ' ui y ' + ui.y);\r\n  }\r\n\r\n  return (\r\n    \r\n    // indicator container div\r\n    // line is 0 + because otherwise it assumes some default strange pos\r\n    // +0 because style transform needs an int in  order to work\r\n    <div id=\"indicator\" style={indicatorDivStyle}>\r\n      \r\n      {/*line*/}\r\n      <svg style={svgLineStyle} width=\"100%\" height=\"100%\" >\r\n        <line id='line'\r\n              style={lineStyle}\r\n              x1={props.x1 + 0}\r\n              y1={props.y1 + 0}\r\n              x2={props.x2 + 0}\r\n              y2={props.y2 + 0} />\r\n      </svg>\r\n\r\n      {/*handle l*/}\r\n      <Draggable\r\n        id='draggable1'\r\n        axis=\"both\"\r\n        handle=\".handle\"\r\n        position={{x: props.x1, y: props.y1}}\r\n        scale={1}\r\n        onDrag={handleMove5}\r\n        // onStop={handleStop5p}\r\n        >  \r\n        \r\n        <div id='handle1'>\r\n    \r\n          <svg style={svgteststyle}    \r\n            className=\"handle\"\r\n            width='5em'\r\n            height=\"5em\"\r\n            viewBox=\"56 56 112 112\">\r\n\r\n            <circle style={circleStyle} cx={'112'} cy={'112'} r={'25'}/>\r\n          </svg>\r\n        </div>\r\n      </Draggable>\r\n\r\n      {/*handle r*/}\r\n      <Draggable\r\n        id='draggable2'\r\n        axis=\"both\"\r\n        handle=\".handle\"\r\n        position={{x: props.x2, y: props.y2}}\r\n        scale={1}\r\n        onDrag={handleMove6}\r\n        >  \r\n        \r\n        <div id='handle2'>\r\n      \r\n          <svg style={svgteststyle}    \r\n            className=\"handle\"\r\n            width='5em'\r\n            height=\"5em\"\r\n            viewBox=\"0 0 112 112\">\r\n\r\n            <circle style={circleStyle} cx={'56'} cy={'56'} r={'25'}/>\r\n          </svg>\r\n        </div>\r\n      </Draggable>\r\n\r\n\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Indicator;","\r\n/*\r\nimage from which to extract data,\r\nbased on position of indicator line overlay\r\nalternatively not background but html element: <img src={image} alt=\"\" style={imageStyle}/>\r\n\r\nthere are two spots for css: Image.css and const divStyle\r\n  this is because some elements are supposed to be dynamic, like opacity and image choice\r\n\r\ncutout       <p id='bildetTitle' >draggable circles adjust line measuring image brightness</p>\r\n\r\n\r\n*/\r\n\r\n// todo: get size of parent on which to stretch canvas\r\n\r\nimport React, { useEffect } from 'react';\r\n// import image from './images/texture.jpg'; // here we are importing the image\r\nimport image from \"./images/stones.jpg\"\r\nimport Indicator from './Indicator';\r\nimport './Bildet.css';\r\n\r\nfunction Bildet (props) {\r\n\r\n  // for things that should not happen before render\r\n  //   in this case, get element by id cannot happen before render, as it does not exist then\r\n  //\r\n  // added second parameter [] to useEffect if to run just once (not everytime state gets updated)\r\n  // the second param [] is an array of variables that the component will check to make sure changed before re-rendering\r\n  useEffect(() => {\r\n\r\n    // this cannot happen before render as the canvas does not exist before render (or can it now?)\r\n    initCanvas();\r\n  }, []);\r\n\r\n  function initCanvas () {\r\n    var canvasPic = document.getElementById(\"canvasPic\");\r\n    var ctx = canvasPic.getContext(\"2d\");\r\n\r\n    ctx.clearRect(0, 0, 120, 400);\r\n    ctx.fillStyle = \"#0000F2\";         // make background fill (is this necessary?)\r\n    ctx.fillRect(0, 0, 1120, 364);\r\n\r\n    var imageObj = new Image();\r\n    imageObj.src = image;\r\n    imageObj.onload = function() {\r\n      //void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\r\n\r\n      ctx.drawImage(imageObj, 0, 0, 2500, 600, 0, 0, 2500, 600);\r\n    };\r\n\r\n    // test drawing\r\n    ctx.strokeStyle = \"#AA9999\";\r\n    ctx.lineWidth = 3;\r\n    ctx.moveTo(50, 300);\r\n    ctx.lineTo(90, 210);\r\n    ctx.stroke();\r\n  }\r\n\r\n  return (\r\n    <div id='bildet'>\r\n      <canvas ref={props.passRef} id=\"canvasPic\" width={'1120'} height=\"364\"></canvas>\r\n      <Indicator \r\n        frameWidth={props.frameWidth}\r\n        bildetHeight={props.bildetHeight}\r\n        x1={props.x1}\r\n        y1={props.y1}\r\n        x2={props.x2}\r\n        y2={props.y2}\r\n        xyChange={props.xyChange}/>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Bildet;","//image from which to extract data, based on position of indicator line overlay\r\n//cutout       <p id='graphTitle'>graph represents image brightness along line between circles</p>\r\n\r\n\r\nimport React, { useEffect } from 'react';\r\nimport './Graph.css';\r\n\r\nfunction Graph (props) {\r\n  return (\r\n    <div className='graph'> {/*comment here*/}\r\n      <canvas ref={props.passRef} id=\"drawingCanvas\" width={props.drawingCanvasWidth} height={props.drawingCanvasHeight}></canvas>\r\n      <svg id='playIndexLine' viewBox=\"0 0 100 100\" preserveAspectRatio=\"none\" >\r\n        <line id='line' x1='50' y1='0' x2='50' y2='100' />\r\n      </svg>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Graph;\r\n\r\n// <rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" />\r\n\r\n","\r\n/*\r\nimage from which to extract data,\r\nbased on position of indicator line overlay\r\nalternatively not background but html element: <img src={image} alt=\"\" style={imageStyle}/>\r\n\r\nthere are two spots for css: Image.css and const divStyle\r\n  this is because some elements are supposed to be dynamic, like opacity and image choice\r\n*/\r\n\r\n// todo: get size of parent on which to stretch canvas\r\n// cutout <p id='animatorTitle' >play CSS transition following brightness graph left to right</p>\r\n\r\n\r\nimport './Animator.css';\r\n\r\nfunction Animator (props) {\r\n\r\n  return (\r\n    <div id='ani' className='animator'>\r\n      <svg onClick={props.animate} id='playTriangle' viewBox=\"0 0 85 100\">\r\n        <polygon points=\"0,0 0,100 85,50\"/>\r\n      </svg>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Animator;","// this is from https://usehooks.com/useWindowSize/\r\n\r\nimport { useState, useEffect } from 'react';\r\n\r\n// Hook\r\nfunction useWindowSize() {\r\n  // Initialize state with undefined width/height so server and client renders match\r\n  // Learn more here: https://joshwcomeau.com/react/the-perils-of-rehydration/\r\n  const [windowSize, setWindowSize] = useState({\r\n    width: undefined,\r\n    height: undefined,\r\n  });\r\n\r\n  useEffect(() => {\r\n    // Handler to call on window resize\r\n    \r\n    // Add event listener\r\n    window.addEventListener(\"resize\", handleResize);\r\n    \r\n    // Call handler right away so state gets updated with initial window size\r\n    handleResize();\r\n    \r\n    // Remove event listener on cleanup\r\n    return () => window.removeEventListener(\"resize\", handleResize);\r\n  }, []); // Empty array ensures that effect is only run on mount\r\n\r\n  function handleResize() {\r\n    // Set window width/height to state\r\n    setWindowSize({\r\n      width: window.innerWidth, //document.getElementById('frame').getBoundingClientRect().width,\r\n      height: window.innerHeight,\r\n    });\r\n  }\r\n\r\n  return windowSize;\r\n}\r\n\r\nexport default useWindowSize","/*\r\nthis, Frame.js, is the container\r\n  for the image object and indicator objects and graph object and settings\r\nits purpose is\r\n  to be a centered, dynamically resizing container in which to place its children\r\nit is vertically centered and full screen width up to 70 em\r\n\r\ncutout: <p onClick={redraw} id='titlen'>CSS transition from image</p>\r\n*/\r\n\r\nimport React, {useState, useEffect, useRef} from 'react';\r\nimport './Frame.css';\r\nimport Bildet from './Bildet'; // import image object to display\r\nimport Graph from './Graph';\r\nimport Animator from './Animator';\r\nimport useWindowSize from './useWindowSize';\r\nimport './curve.js';\r\nimport LPF from './LPF.js';\r\nimport {ma, dma, ema, sma, wma} from 'moving-averages'\r\nimport image from \"./images/stones.jpg\"\r\n\r\nfunction Frame() {\r\n\r\n  const [frameWidth, setFrameWidth] = useState(100);\r\n  const [bildetHeight, setBildetHeight] = useState(100);\r\n  const [drawingCanvasWidth, setDrawingCanvasWidth] = useState(null);\r\n  const [drawingCanvasHeight, setDrawingCanvasHeight] = useState(null);\r\n  const [graphHeight, setGraphHeight] = useState(null);\r\n\r\n  // references for canvas before it is initialized\r\n  const imageCanvasRef = useRef(null);\r\n  const drawingCanvasRef = useRef(null);\r\n\r\n  // state variables\r\n  const [x1, setX1] = useState(100);    // indicator endpoint 1 x coordinate\r\n  const [y1, setY1] = useState(200);    //   and y coordinate\r\n  const [x2, setX2] = useState(300);    // indicator endpoint 2 x coordinate\r\n  const [y2, setY2] = useState(200);    //   and y coordinate\r\n\r\n  const [x1p, setX1p] = useState(0.57);    // indicator endpoint 1 x coordinate\r\n  const [y1p, setY1p] = useState(0.8);    //   and y coordinate\r\n  const [x2p, setX2p] = useState(0.7);    // indicator endpoint 2 x coordinate\r\n  const [y2p, setY2p] = useState(0.5);    //   and y coordinate\r\n\r\n  const defaultX1 = 100;\r\n  const defaultY1 = 270;\r\n  const defaultX2 = 100;\r\n  const defaultY2 = 200;\r\n\r\n  const [smooth, setSmooth] = useState(3);    // indicator endpoint 1 x coordinate\r\n\r\n  // dynamic number of points based on length of line, or static 100 points?\r\n  const numberOfPoints = 100;\r\n  const [calibratePoint, setCalibratePoint] = useState(0);\r\n\r\n  // initialize array for points of color along line\r\n  var points = [];\r\n\r\n  // on first render\r\n  useEffect(() => {\r\n\r\n    // get width, height from frame, set canvas dimensions\r\n    setDrawingCanvasWidth(document.getElementById('drawingCanvas').getBoundingClientRect().width);\r\n    setDrawingCanvasHeight(document.getElementById('drawingCanvas').getBoundingClientRect().height);\r\n    initCanvas(drawingCanvasWidth, drawingCanvasHeight);\r\n\r\n    // add event listener for resizing\r\n    window.addEventListener(\"resize\", handleResize);\r\n\r\n    // call handler right away so state gets updated with initial window size\r\n    handleResize();\r\n\r\n    plotDelay();\r\n\r\n  }, []);\r\n\r\n  // on every change in state\r\n  useEffect(() => {\r\n    // console.log('hver gang noe endres i frame'); // som når resize trigger [set]\r\n\r\n    plotLine();\r\n\r\n    // this is what scales handles and line !!\r\n    setX1(x1p * frameWidth);\r\n    setY1(bildetHeight * y1p);\r\n\r\n    setX2(frameWidth * x2p);\r\n    setY2(bildetHeight * y2p);\r\n  });\r\n\r\n\r\n  function plotDelay() {\r\n\r\n    setTimeout(function() {\r\n        \r\n      setX1(x1p * frameWidth);\r\n      setY1(bildetHeight * y1p);\r\n\r\n      setX2(frameWidth * x2p);\r\n      setY2(bildetHeight * y2p);\r\n    }, 250);\r\n  }\r\n\r\n\r\n\r\n\r\n  // initialize canvases\r\n  function initCanvas (initx, inity) {\r\n\r\n    const imageCtx = imageCanvasRef.current.getContext(\"2d\");\r\n    const drawCtx = drawingCanvasRef.current.getContext(\"2d\");\r\n\r\n    imageCtx.fillStyle = \"#FAFAFA\";\r\n\r\n    // make background fill - is this necessary?\r\n    drawCtx.fillStyle = \"#FAF2F2\";\r\n    drawCtx.fillRect(0, 0, initx, inity);\r\n\r\n    drawCtx.strokeStyle = \"#AA9999\";\r\n    drawCtx.lineWidth = 2;\r\n  }\r\n\r\n  // record handle positions for use by line drawing and line scanning\r\n  function setXY(handleID, xgot, ygot) {\r\n    if (handleID == 0) {\r\n      // console.log('nå flytter vi');\r\n\r\n      setX1p(xgot / frameWidth);\r\n      // console.log('xgot ' + xgot + ' frameWidth ' + frameWidth + ' x1p ' + x1p);\r\n      setX1(frameWidth * x1p);\r\n      setY1p(ygot / bildetHeight);\r\n      setY1(frameWidth * y1p);\r\n    }\r\n    if (handleID == 1) {\r\n      setX2p(xgot / frameWidth);\r\n      setX2(frameWidth * x2p);\r\n      setY2p(ygot / bildetHeight);\r\n      setY2(frameWidth * y2p);\r\n    }\r\n  }\r\n\r\n  function handleResize() {\r\n    // Set window width/height to state\r\n    setFrameWidth(document.getElementById('frame').getBoundingClientRect().width);\r\n    setBildetHeight(document.getElementById('bildet').getBoundingClientRect().height);\r\n\r\n    // console.log('resized');\r\n  }\r\n\r\n  // function for drawing graph from line, walk through coordinates of line, for each point extract colo value and plot on graph\r\n  function plotLine () {\r\n    console.log(\"plot\");\r\n\r\n    // is there a more ... way of doing this check for exist, etc.?\r\n    const imageCtx = imageCanvasRef.current.getContext(\"2d\");\r\n    const drawCtx = drawingCanvasRef.current.getContext(\"2d\");\r\n\r\n    drawCtx.clearRect(0, 0, drawingCanvasWidth, drawingCanvasHeight);\r\n    drawCtx.strokeStyle = \"#AA9999\";\r\n    drawCtx.lineWidth = 1.0;\r\n    drawCtx.lineCap = 'round';\r\n    drawCtx.beginPath();\r\n\r\n    // special coordinates for extracting data\r\n    // here we are scaling x and y to account for mismatch due to static width image source vs potentially resized canvas\r\n    // !!1120\r\n    const lx1 = x1 * (1120 / frameWidth);\r\n    const ly1 = y1 * (1120 / frameWidth);\r\n    const lx2 = x2 * (1120 / frameWidth);\r\n    const ly2 = y2 * (1120 / frameWidth);\r\n\r\n    const firstColorPoint = 255 - imageCtx.getImageData(lx1, ly1, 1, 1).data[0];\r\n    const lastColorPoint = 255 - imageCtx.getImageData(lx2, ly2, 1, 1).data[0];\r\n\r\n    // console.log('first color point ' + firstColorPoint);\r\n\r\n    // populate points array with color values along line\r\n    for (let i=0; i<numberOfPoints; i++) {\r\n\r\n      // get color data from pixel at current point along line\r\n      var data = imageCtx.getImageData(lx1 + ((lx2 - lx1) / numberOfPoints * i), ly1 + ((ly2 - ly1) / numberOfPoints * i), 1, 1).data;\r\n\r\n      // append new value to the array\r\n      points.push(255 - data[1]);\r\n    }\r\n\r\n    // filter points\r\n    points = filter(points, firstColorPoint, lastColorPoint);\r\n\r\n    // set starting point\r\n    drawCtx.moveTo(0, points[0] / 255 * drawingCanvasHeight);\r\n\r\n    // draw points on canvas\r\n    for (let i=1; i<numberOfPoints; i++) {\r\n      drawCtx.lineTo(drawingCanvasWidth/numberOfPoints*i, points[i] / 255 * drawingCanvasHeight);\r\n    }\r\n\r\n    drawCtx.lineTo(drawingCanvasWidth, points[numberOfPoints] / 255 * drawingCanvasHeight);\r\n\r\n    \r\n    drawCtx.stroke();\r\n\r\n    setCalibratePoint(points[0]);\r\n\r\n  }\r\n\r\n  // filtering points to be graphed, using LPF library\r\n  function filter (points, firstColorPoint, lastColorPoint) {\r\n\r\n    // duplicate backwards 30 times for lowpass to be able to smooth backwards\r\n    for (var i=0; i < 30; i++) {\r\n      points.unshift(firstColorPoint);\r\n    }\r\n\r\n    // duplicate forwards 30 times for lowpass to be able to smooth forwards\r\n    for (var i=0; i < 30; i++) {\r\n      points.push(lastColorPoint);\r\n    }\r\n \r\n    points = ema(points, smooth);\r\n    points = ema(points, smooth);\r\n    points = ema(points, smooth);\r\n    points = ema(points, smooth);\r\n    points = ema(points, smooth);\r\n\r\n    // remove 30 pre points again\r\n    points.splice(0, 30);\r\n\r\n    return points\r\n  }\r\n\r\n  function animate () {\r\n\r\n    // make play index visible\r\n    document.getElementById(\"playIndexLine\").style.visibility = \"visible\";\r\n    // document.getElementById(\"playIndexLine\").style.visibility = \"hidden\";\r\n    console.log(document.getElementById(\"playIndexLine\").style.visibility);\r\n\r\n\r\n    // maybe screen animation instead\r\n    const myVar = setInterval(playOneFrame, 15);\r\n\r\n    let direction = 1;\r\n    let i = 0;\r\n\r\n    // establish zero value from points[i]\r\n    const valueAtZero = points[0];\r\n\r\n    function playOneFrame() {\r\n\r\n      // get width of play triangle ?!\r\n      \r\n      // draw index line\r\n      // make sure this function cannot trigger while already active      \r\n      // current issue: must establish line 0 as center for play and line max as max right of play\r\n      document.getElementById(\"playIndexLine\").style.transform = \"translate(\" + (((frameWidth) / numberOfPoints) * i) + \"px)\";\r\n\r\n      // draw play triangle\r\n      document.getElementById(\"playTriangle\").style.transform = \"translate(\" + (-1 * ((points[i] / 255) - (valueAtZero / 255)) * ((frameWidth / 2) - 30) + \"px)\");\r\n\r\n      if (direction === 1) {i++;}\r\n      if (direction === 0) {i--;}\r\n      if (i === numberOfPoints) {direction = 0;}\r\n      if(i === -1){\r\n        direction = 1;\r\n        clearInterval(myVar);\r\n\r\n        // make play index invisible\r\n        document.getElementById(\"playIndexLine\").style.visibility = \"hidden\";\r\n      }\r\n    }\r\n\r\n\r\n  }\r\n\r\n  return (\r\n    <div id=\"frame\">\r\n\r\n      <Bildet\r\n        plotLine={plotLine}\r\n        passRef={imageCanvasRef}\r\n        x1={x1} y1={y1} x2={x2} y2={y2}\r\n        xyChange={setXY}\r\n        frameWidth={frameWidth}\r\n        bildetHeight={bildetHeight}/>    \r\n      <Graph\r\n        passRef={drawingCanvasRef}\r\n        drawingCanvasWidth={drawingCanvasWidth}\r\n        drawingCanvasHeight={drawingCanvasHeight} />\r\n      <Animator \r\n        animate={animate}/>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Frame;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* \r\n    cutouts:\r\n\r\n    // set low pass factor\r\n    LPF.smoothing = 0.5;\r\n\r\n    // do the filtering\r\n    LPF.smoothArray(points)\r\n\r\n    // for fill\r\n    drawCtx.lineTo(drawingCanvasWidth, drawingCanvasHeight/2);      \r\n    drawCtx.lineTo(drawingCanvasWidth, drawingCanvasHeight);      \r\n    drawCtx.fillStyle = \"#EEDDDD\";\r\n    drawCtx.fill();\r\n    \r\n    // for smooting (but do i need smooting when i have low pass?\r\n    drawCtx.curve(points2, 0.2);\r\n\r\n\r\n    //points = sma(points, 2, 1.7);\r\n    //points = sma(points, 10, 2.1);\r\n    //points = sma(points, 10, 2.1);\r\n    //points = sma(points, 10, 2.1);\r\n    //points = sma(points, 10, 2.1);\r\n    //points = sma(points, 10, 2.1);\r\n\r\n    // not currently doing dynamic horizontal move of play button\r\n    // document.getElementById(\"playTriangle\").style.transform = \"translate(\" + (0 - (points[0] + calibratePoint)) + \"px)\";\r\n\r\n  function redraw() {\r\n\r\n    /*\r\n    var canvasPic = document.getElementById(\"canvasPic\");\r\n    var ctx = canvasPic.getContext(\"2d\");\r\n\r\n    ctx.clearRect(0, 0, 12, 40);\r\n    ctx.fillStyle = \"#00FFF2\";         // make background fill (is this necessary?)\r\n    ctx.fillRect(0, 0, 112, 36);\r\n\r\n    var imageObj = new Image();\r\n    imageObj.src = image;\r\n    imageObj.onload = function() {\r\n      //void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\r\n\r\n      ctx.drawImage(imageObj, 0, 0, frameWidth, 100);\r\n    };\r\n    \r\n\r\n    // console.log('redraw ');\r\n  }\r\n\r\n * Gets computed translate values\r\n * @param {HTMLElement} element\r\n * @returns {Object}\r\n \r\n\r\nfunction getTranslateValues (element) {\r\n  const style = window.getComputedStyle(element)\r\n  const matrix = style.transform || style.webkitTransform || style.mozTransform\r\n\r\n  // No transform property. Simply return 0 values.\r\n  if (matrix === 'none') {\r\n    return {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0\r\n    }\r\n  }\r\n\r\n  // Can either be 2d or 3d transform\r\n  const matrixType = matrix.includes('3d') ? '3d' : '2d'\r\n  const matrixValues = matrix.match(/matrix.*\\((.+)\\)/)[1].split(', ')\r\n\r\n  // 2d matrices have 6 values\r\n  // Last 2 values are X and Y.\r\n  // 2d matrices does not have Z value.\r\n  if (matrixType === '2d') {\r\n    return {\r\n      x: matrixValues[4],\r\n      y: matrixValues[5],\r\n      z: 0\r\n    }\r\n  }\r\n\r\n  // 3d matrices have 16 values\r\n  // The 13th, 14th, and 15th values are X, Y, and Z\r\n  if (matrixType === '3d') {\r\n    return {\r\n      x: matrixValues[12],\r\n      y: matrixValues[13],\r\n      z: matrixValues[14]\r\n    }\r\n  }\r\n}\r\n\r\n\r\n    // console.log('x === ' + e.screenX);\r\n    setSmooth(((e.screenX) / 50) - 7.3 );\r\n    console.log('smooth ' + smooth);\r\n    if (smooth <= 1.1) {\r\n      setSmooth(1.11);\r\n    }\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","/*\n\nthis, App.js, is the container for the frame object.\nits purpose is\n  to be a full screen colored background on which to center the frame\n  \n*/\n\n\nimport './App.css';          // import style sheet for this js file\nimport Frame from './Frame'; // import frame object to display\n\nfunction App() {\n  return (\n    \n    <div id='wrapperDiv'>\n      <Frame />\n    </div>\n  );\n}\n\nexport default App;\n","// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport default function register() {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebookincubator/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (!isLocalhost) {\n        // Is not local host. Just register service worker\n        registerValidSW(swUrl);\n      } else {\n        // This is running on localhost. Lets check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the old content will have been purged and\n              // the fresh content will have been added to the cache.\n              // It's the perfect time to display a \"New content is\n              // available; please refresh.\" message in your web app.\n              console.log('New content is available; please refresh.');\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport registerServiceWorker from './registerServiceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\nregisterServiceWorker();\n"],"sourceRoot":""}